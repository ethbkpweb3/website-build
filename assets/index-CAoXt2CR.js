import {
    eP as e,
    bh as t,
    dl as n,
    H as r
} from "./index-CQfCy4Xm.js";
import {
    e as i
} from "./events-Dm2NiFyR.js";
import {
    r as s
} from "./___vite-browser-external_commonjs-proxy-CX5ghsV-.js";
var a = {},
    o = {},
    c = {};
Object.defineProperty(c, "__esModule", {
    value: !0
}), c.walletLogo = void 0;
c.walletLogo = (e, t) => {
    let n;
    switch (e) {
        case "standard":
        default:
            return n = t, `data:image/svg+xml,%3Csvg width='${t}' height='${n}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
        case "circle":
            return n = t, `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${t}' height='${n}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
        case "text":
            return n = (.1 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogo":
            return n = (.25 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        case "textLight":
            return n = (.1 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogoLight":
            return n = (.25 * t).toFixed(2), `data:image/svg+xml,%3Csvg width='${t}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`
    }
};
var l = {},
    u = {
        exports: {}
    };
! function(e) {
    var t = Object.prototype.hasOwnProperty,
        n = "~";

    function r() {}

    function i(e, t, n) {
        this.fn = e, this.context = t, this.once = n || !1
    }

    function s(e, t, r, s, a) {
        if ("function" != typeof r) throw new TypeError("The listener must be a function");
        var o = new i(r, s || e, a),
            c = n ? n + t : t;
        return e._events[c] ? e._events[c].fn ? e._events[c] = [e._events[c], o] : e._events[c].push(o) : (e._events[c] = o, e._eventsCount++), e
    }

    function a(e, t) {
        0 == --e._eventsCount ? e._events = new r : delete e._events[t]
    }

    function o() {
        this._events = new r, this._eventsCount = 0
    }
    Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), o.prototype.eventNames = function() {
        var e, r, i = [];
        if (0 === this._eventsCount) return i;
        for (r in e = this._events) t.call(e, r) && i.push(n ? r.slice(1) : r);
        return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
    }, o.prototype.listeners = function(e) {
        var t = n ? n + e : e,
            r = this._events[t];
        if (!r) return [];
        if (r.fn) return [r.fn];
        for (var i = 0, s = r.length, a = new Array(s); i < s; i++) a[i] = r[i].fn;
        return a
    }, o.prototype.listenerCount = function(e) {
        var t = n ? n + e : e,
            r = this._events[t];
        return r ? r.fn ? 1 : r.length : 0
    }, o.prototype.emit = function(e, t, r, i, s, a) {
        var o = n ? n + e : e;
        if (!this._events[o]) return !1;
        var c, l, u = this._events[o],
            d = arguments.length;
        if (u.fn) {
            switch (u.once && this.removeListener(e, u.fn, void 0, !0), d) {
                case 1:
                    return u.fn.call(u.context), !0;
                case 2:
                    return u.fn.call(u.context, t), !0;
                case 3:
                    return u.fn.call(u.context, t, r), !0;
                case 4:
                    return u.fn.call(u.context, t, r, i), !0;
                case 5:
                    return u.fn.call(u.context, t, r, i, s), !0;
                case 6:
                    return u.fn.call(u.context, t, r, i, s, a), !0
            }
            for (l = 1, c = new Array(d - 1); l < d; l++) c[l - 1] = arguments[l];
            u.fn.apply(u.context, c)
        } else {
            var h, f = u.length;
            for (l = 0; l < f; l++) switch (u[l].once && this.removeListener(e, u[l].fn, void 0, !0), d) {
                case 1:
                    u[l].fn.call(u[l].context);
                    break;
                case 2:
                    u[l].fn.call(u[l].context, t);
                    break;
                case 3:
                    u[l].fn.call(u[l].context, t, r);
                    break;
                case 4:
                    u[l].fn.call(u[l].context, t, r, i);
                    break;
                default:
                    if (!c)
                        for (h = 1, c = new Array(d - 1); h < d; h++) c[h - 1] = arguments[h];
                    u[l].fn.apply(u[l].context, c)
            }
        }
        return !0
    }, o.prototype.on = function(e, t, n) {
        return s(this, e, t, n, !1)
    }, o.prototype.once = function(e, t, n) {
        return s(this, e, t, n, !0)
    }, o.prototype.removeListener = function(e, t, r, i) {
        var s = n ? n + e : e;
        if (!this._events[s]) return this;
        if (!t) return a(this, s), this;
        var o = this._events[s];
        if (o.fn) o.fn !== t || i && !o.once || r && o.context !== r || a(this, s);
        else {
            for (var c = 0, l = [], u = o.length; c < u; c++)(o[c].fn !== t || i && !o[c].once || r && o[c].context !== r) && l.push(o[c]);
            l.length ? this._events[s] = 1 === l.length ? l[0] : l : a(this, s)
        }
        return this
    }, o.prototype.removeAllListeners = function(e) {
        var t;
        return e ? (t = n ? n + e : e, this._events[t] && a(this, t)) : (this._events = new r, this._eventsCount = 0), this
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, e.exports = o
}(u);
var d = u.exports,
    h = {},
    f = {};
Object.defineProperty(f, "__esModule", {
    value: !0
}), f.errorValues = f.standardErrorCodes = void 0, f.standardErrorCodes = {
    rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
    },
    provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901,
        unsupportedChain: 4902
    }
}, f.errorValues = {
    "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
    },
    "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
    },
    "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
    },
    "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
    },
    "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
    },
    "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
    },
    "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
    },
    "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
    },
    "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
    },
    4001: {
        standard: "EIP-1193",
        message: "User rejected the request."
    },
    4100: {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
    },
    4901: {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
    },
    4902: {
        standard: "EIP-3085",
        message: "Unrecognized chain ID."
    }
};
var p = {},
    _ = {};
! function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.serialize = e.getErrorCode = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    const t = f,
        n = "Unspecified error message.";

    function r(r, i = n) {
        if (r && Number.isInteger(r)) {
            const n = r.toString();
            if (o(t.errorValues, n)) return t.errorValues[n].message;
            if (s(r)) return e.JSON_RPC_SERVER_ERROR_MESSAGE
        }
        return i
    }

    function i(e) {
        if (!Number.isInteger(e)) return !1;
        const n = e.toString();
        return !!t.errorValues[n] || !!s(e)
    }

    function s(e) {
        return e >= -32099 && e <= -32e3
    }

    function a(e) {
        return e && "object" == typeof e && !Array.isArray(e) ? Object.assign({}, e) : e
    }

    function o(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }

    function c(e, t) {
        return "object" == typeof e && null !== e && t in e && "string" == typeof e[t]
    }
    e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.", e.getMessageFromCode = r, e.isValidCode = i, e.getErrorCode = function(e) {
        var t;
        return "number" == typeof e ? e : function(e) {
            return "object" == typeof e && null !== e && ("number" == typeof e.code || "number" == typeof e.errorCode)
        }(e) ? null !== (t = e.code) && void 0 !== t ? t : e.errorCode : void 0
    }, e.serialize = function(e, {
        shouldIncludeStack: s = !1
    } = {}) {
        const l = {};
        if (e && "object" == typeof e && !Array.isArray(e) && o(e, "code") && i(e.code)) {
            const t = e;
            l.code = t.code, t.message && "string" == typeof t.message ? (l.message = t.message, o(t, "data") && (l.data = t.data)) : (l.message = r(l.code), l.data = {
                originalError: a(e)
            })
        } else l.code = t.standardErrorCodes.rpc.internal, l.message = c(e, "message") ? e.message : n, l.data = {
            originalError: a(e)
        };
        return s && (l.stack = c(e, "stack") ? e.stack : void 0), l
    }
}(_), Object.defineProperty(p, "__esModule", {
    value: !0
}), p.standardErrors = void 0;
const g = f,
    m = _;

function b(e, t) {
    const [n, r] = v(t);
    return new w(e, n || (0, m.getMessageFromCode)(e), r)
}

function y(e, t) {
    const [n, r] = v(t);
    return new E(e, n || (0, m.getMessageFromCode)(e), r)
}

function v(e) {
    if (e) {
        if ("string" == typeof e) return [e];
        if ("object" == typeof e && !Array.isArray(e)) {
            const {
                message: t,
                data: n
            } = e;
            if (t && "string" != typeof t) throw new Error("Must specify string message.");
            return [t || void 0, n]
        }
    }
    return []
}
p.standardErrors = {
    rpc: {
        parse: e => b(g.standardErrorCodes.rpc.parse, e),
        invalidRequest: e => b(g.standardErrorCodes.rpc.invalidRequest, e),
        invalidParams: e => b(g.standardErrorCodes.rpc.invalidParams, e),
        methodNotFound: e => b(g.standardErrorCodes.rpc.methodNotFound, e),
        internal: e => b(g.standardErrorCodes.rpc.internal, e),
        server: e => {
            if (!e || "object" != typeof e || Array.isArray(e)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
            const {
                code: t
            } = e;
            if (!Number.isInteger(t) || t > -32005 || t < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
            return b(t, e)
        },
        invalidInput: e => b(g.standardErrorCodes.rpc.invalidInput, e),
        resourceNotFound: e => b(g.standardErrorCodes.rpc.resourceNotFound, e),
        resourceUnavailable: e => b(g.standardErrorCodes.rpc.resourceUnavailable, e),
        transactionRejected: e => b(g.standardErrorCodes.rpc.transactionRejected, e),
        methodNotSupported: e => b(g.standardErrorCodes.rpc.methodNotSupported, e),
        limitExceeded: e => b(g.standardErrorCodes.rpc.limitExceeded, e)
    },
    provider: {
        userRejectedRequest: e => y(g.standardErrorCodes.provider.userRejectedRequest, e),
        unauthorized: e => y(g.standardErrorCodes.provider.unauthorized, e),
        unsupportedMethod: e => y(g.standardErrorCodes.provider.unsupportedMethod, e),
        disconnected: e => y(g.standardErrorCodes.provider.disconnected, e),
        chainDisconnected: e => y(g.standardErrorCodes.provider.chainDisconnected, e),
        unsupportedChain: e => y(g.standardErrorCodes.provider.unsupportedChain, e),
        custom: e => {
            if (!e || "object" != typeof e || Array.isArray(e)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
            const {
                code: t,
                message: n,
                data: r
            } = e;
            if (!n || "string" != typeof n) throw new Error('"message" must be a nonempty string');
            return new E(t, n, r)
        }
    }
};
class w extends Error {
    constructor(e, t, n) {
        if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
        if (!t || "string" != typeof t) throw new Error('"message" must be a nonempty string.');
        super(t), this.code = e, void 0 !== n && (this.data = n)
    }
}
class E extends w {
    constructor(e, t, n) {
        if (! function(e) {
                return Number.isInteger(e) && e >= 1e3 && e <= 4999
            }(e)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        super(e, t, n)
    }
}! function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.standardErrors = e.standardErrorCodes = void 0;
    var t = f;
    Object.defineProperty(e, "standardErrorCodes", {
        enumerable: !0,
        get: function() {
            return t.standardErrorCodes
        }
    });
    var n = p;
    Object.defineProperty(e, "standardErrors", {
        enumerable: !0,
        get: function() {
            return n.standardErrors
        }
    })
}(h);
var S = {},
    k = {};
Object.defineProperty(k, "__esModule", {
    value: !0
}), k.isErrorResponse = void 0, k.isErrorResponse = function(e) {
    return void 0 !== e.errorMessage
};
var C = {};
Object.defineProperty(C, "__esModule", {
    value: !0
}), C.LIB_VERSION = void 0, C.LIB_VERSION = "4.0.3", Object.defineProperty(S, "__esModule", {
    value: !0
}), S.serializeError = void 0;
const I = k,
    M = C,
    R = f,
    x = _;
S.serializeError = function(e, t) {
    const n = (0, x.serialize)(function(e) {
            if ("string" == typeof e) return {
                message: e,
                code: R.standardErrorCodes.rpc.internal
            };
            if ((0, I.isErrorResponse)(e)) return Object.assign(Object.assign({}, e), {
                message: e.errorMessage,
                code: e.errorCode,
                data: {
                    method: e.method
                }
            });
            return e
        }(e), {
            shouldIncludeStack: !0
        }),
        r = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    r.searchParams.set("version", M.LIB_VERSION), r.searchParams.set("code", n.code.toString());
    const i = function(e, t) {
        const n = null == e ? void 0 : e.method;
        if (n) return n;
        if (void 0 === t) return;
        if ("string" == typeof t) return t;
        if (!Array.isArray(t)) return t.method;
        if (t.length > 0) return t[0].method;
        return
    }(n.data, t);
    return i && r.searchParams.set("method", i), r.searchParams.set("message", n.message), Object.assign(Object.assign({}, n), {
        docUrl: r.href
    })
};
var L = {};

function A() {
    return e => e
}
Object.defineProperty(L, "__esModule", {
    value: !0
}), L.RegExpString = L.IntNumber = L.BigIntString = L.AddressString = L.HexString = L.OpaqueType = void 0, L.OpaqueType = A, L.HexString = e => e, L.AddressString = e => e, L.BigIntString = e => e, L.IntNumber = function(e) {
    return Math.floor(e)
}, L.RegExpString = e => e;
var P = {};
Object.defineProperty(P, "__esModule", {
    value: !0
}), P.areAddressArraysEqual = P.getFavicon = P.range = P.isBigNumber = P.ensureParsedJSONObject = P.ensureBigInt = P.ensureRegExpString = P.ensureIntNumber = P.ensureBuffer = P.ensureAddressString = P.ensureEvenLengthHexString = P.ensureHexString = P.isHexString = P.prepend0x = P.strip0x = P.has0xPrefix = P.hexStringFromIntNumber = P.intNumberFromHexString = P.bigIntStringFromBigInt = P.hexStringFromBuffer = P.hexStringToUint8Array = P.uint8ArrayToHex = P.randomBytesHex = void 0;
const T = h,
    j = L,
    N = /^[0-9]*$/,
    O = /^[a-f0-9]*$/;

function D(e) {
    return [...e].map((e => e.toString(16).padStart(2, "0"))).join("")
}

function B(e) {
    return e.startsWith("0x") || e.startsWith("0X")
}

function U(e) {
    return B(e) ? e.slice(2) : e
}

function W(e) {
    return B(e) ? `0x${e.slice(2)}` : `0x${e}`
}

function q(e) {
    if ("string" != typeof e) return !1;
    const t = U(e).toLowerCase();
    return O.test(t)
}

function H(e, t = !1) {
    if ("string" == typeof e) {
        const n = U(e).toLowerCase();
        if (O.test(n)) return (0, j.HexString)(t ? `0x${n}` : n)
    }
    throw T.standardErrors.rpc.invalidParams(`"${String(e)}" is not a hexadecimal string`)
}

function F(e, t = !1) {
    let n = H(e, !1);
    return n.length % 2 == 1 && (n = (0, j.HexString)(`0${n}`)), t ? (0, j.HexString)(`0x${n}`) : n
}

function z(e) {
    if ("number" == typeof e && Number.isInteger(e)) return (0, j.IntNumber)(e);
    if ("string" == typeof e) {
        if (N.test(e)) return (0, j.IntNumber)(Number(e));
        if (q(e)) return (0, j.IntNumber)(Number(BigInt(F(e, !0))))
    }
    throw T.standardErrors.rpc.invalidParams(`Not an integer: ${String(e)}`)
}

function V(e) {
    if (null == e || "function" != typeof e.constructor) return !1;
    const {
        constructor: t
    } = e;
    return "function" == typeof t.config && "number" == typeof t.EUCLID
}
P.randomBytesHex = function(e) {
    return D(crypto.getRandomValues(new Uint8Array(e)))
}, P.uint8ArrayToHex = D, P.hexStringToUint8Array = function(e) {
    return new Uint8Array(e.match(/.{1,2}/g).map((e => parseInt(e, 16))))
}, P.hexStringFromBuffer = function(e, t = !1) {
    const n = e.toString("hex");
    return (0, j.HexString)(t ? `0x${n}` : n)
}, P.bigIntStringFromBigInt = function(e) {
    return (0, j.BigIntString)(e.toString(10))
}, P.intNumberFromHexString = function(e) {
    return (0, j.IntNumber)(Number(BigInt(F(e, !0))))
}, P.hexStringFromIntNumber = function(e) {
    return (0, j.HexString)(`0x${BigInt(e).toString(16)}`)
}, P.has0xPrefix = B, P.strip0x = U, P.prepend0x = W, P.isHexString = q, P.ensureHexString = H, P.ensureEvenLengthHexString = F, P.ensureAddressString = function(e) {
    if ("string" == typeof e) {
        const t = U(e).toLowerCase();
        if (q(t) && 40 === t.length) return (0, j.AddressString)(W(t))
    }
    throw T.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(e)}`)
}, P.ensureBuffer = function(e) {
    if (Buffer.isBuffer(e)) return e;
    if ("string" == typeof e) {
        if (q(e)) {
            const t = F(e, !1);
            return Buffer.from(t, "hex")
        }
        return Buffer.from(e, "utf8")
    }
    throw T.standardErrors.rpc.invalidParams(`Not binary data: ${String(e)}`)
}, P.ensureIntNumber = z, P.ensureRegExpString = function(e) {
    if (e instanceof RegExp) return (0, j.RegExpString)(e.toString());
    throw T.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(e)}`)
}, P.ensureBigInt = function(e) {
    if (null !== e && ("bigint" == typeof e || V(e))) return BigInt(e.toString(10));
    if ("number" == typeof e) return BigInt(z(e));
    if ("string" == typeof e) {
        if (N.test(e)) return BigInt(e);
        if (q(e)) return BigInt(F(e, !0))
    }
    throw T.standardErrors.rpc.invalidParams(`Not an integer: ${String(e)}`)
}, P.ensureParsedJSONObject = function(e) {
    if ("string" == typeof e) return JSON.parse(e);
    if ("object" == typeof e) return e;
    throw T.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(e)}`)
}, P.isBigNumber = V, P.range = function(e, t) {
    return Array.from({
        length: t - e
    }, ((t, n) => e + n))
}, P.getFavicon = function() {
    const e = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]'),
        {
            protocol: t,
            host: n
        } = document.location,
        r = e ? e.getAttribute("href") : null;
    return !r || r.startsWith("javascript:") || r.startsWith("vbscript:") ? null : r.startsWith("http://") || r.startsWith("https://") || r.startsWith("data:") ? r : r.startsWith("//") ? t + r : `${t}//${n}${r}`
}, P.areAddressArraysEqual = function(e, t) {
    return e.length === t.length && e.every(((e, n) => e === t[n]))
};
var K = {},
    Z = {},
    G = {},
    $ = {};
Object.defineProperty($, "__esModule", {
    value: !0
}), $.decryptContent = $.encryptContent = $.importKeyFromHexString = $.exportKeyToHexString = $.decrypt = $.encrypt = $.deriveSharedSecret = $.generateKeyPair = void 0;
const Y = P;
async function J(e, t) {
    const n = crypto.getRandomValues(new Uint8Array(12));
    return {
        iv: n,
        cipherText: await crypto.subtle.encrypt({
            name: "AES-GCM",
            iv: n
        }, e, (new TextEncoder).encode(t))
    }
}
async function Q(e, {
    iv: t,
    cipherText: n
}) {
    const r = await crypto.subtle.decrypt({
        name: "AES-GCM",
        iv: t
    }, e, n);
    return (new TextDecoder).decode(r)
}

function X(e) {
    switch (e) {
        case "public":
            return "spki";
        case "private":
            return "pkcs8"
    }
}
$.generateKeyPair = async function() {
    return crypto.subtle.generateKey({
        name: "ECDH",
        namedCurve: "P-256"
    }, !0, ["deriveKey"])
}, $.deriveSharedSecret = async function(e, t) {
    return crypto.subtle.deriveKey({
        name: "ECDH",
        public: t
    }, e, {
        name: "AES-GCM",
        length: 256
    }, !1, ["encrypt", "decrypt"])
}, $.encrypt = J, $.decrypt = Q, $.exportKeyToHexString = async function(e, t) {
    const n = X(e),
        r = await crypto.subtle.exportKey(n, t);
    return (0, Y.uint8ArrayToHex)(new Uint8Array(r))
}, $.importKeyFromHexString = async function(e, t) {
    const n = X(e),
        r = (0, Y.hexStringToUint8Array)(t).buffer;
    return await crypto.subtle.importKey(n, r, {
        name: "ECDH",
        namedCurve: "P-256"
    }, !0, "private" === e ? ["deriveKey"] : [])
}, $.encryptContent = async function(e, t) {
    return J(t, JSON.stringify(e, ((e, t) => {
        if (!(t instanceof Error)) return t;
        const n = t;
        return Object.assign(Object.assign({}, n.code ? {
            code: n.code
        } : {}), {
            message: n.message
        })
    })))
}, $.decryptContent = async function(e, t) {
    return JSON.parse(await Q(t, e))
};
var ee = {};
Object.defineProperty(ee, "__esModule", {
    value: !0
}), ee.ScopedLocalStorage = void 0;
class te {
    constructor(e, t) {
        this.scope = e, this.module = t
    }
    setItem(e, t) {
        localStorage.setItem(this.scopedKey(e), t)
    }
    getItem(e) {
        return localStorage.getItem(this.scopedKey(e))
    }
    removeItem(e) {
        localStorage.removeItem(this.scopedKey(e))
    }
    clear() {
        const e = this.scopedKey(""),
            t = [];
        for (let n = 0; n < localStorage.length; n++) {
            const r = localStorage.key(n);
            "string" == typeof r && r.startsWith(e) && t.push(r)
        }
        t.forEach((e => localStorage.removeItem(e)))
    }
    scopedKey(e) {
        return `-${this.scope}${this.module?`:${this.module}`:""}:${e}`
    }
    static clearAll() {
        new te("CBWSDK").clear(), new te("walletlink").clear()
    }
}
ee.ScopedLocalStorage = te, Object.defineProperty(G, "__esModule", {
    value: !0
}), G.SCWKeyManager = void 0;
const ne = $,
    re = ee,
    ie = {
        storageKey: "ownPrivateKey",
        keyType: "private"
    },
    se = {
        storageKey: "ownPublicKey",
        keyType: "public"
    },
    ae = {
        storageKey: "peerPublicKey",
        keyType: "public"
    };
G.SCWKeyManager = class {
    constructor() {
        this.storage = new re.ScopedLocalStorage("CBWSDK", "SCWKeyManager"), this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null
    }
    async getOwnPublicKey() {
        return await this.loadKeysIfNeeded(), this.ownPublicKey
    }
    async getSharedSecret() {
        return await this.loadKeysIfNeeded(), this.sharedSecret
    }
    async setPeerPublicKey(e) {
        this.sharedSecret = null, this.peerPublicKey = e, await this.storeKey(ae, e), await this.loadKeysIfNeeded()
    }
    async clear() {
        this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null, this.storage.removeItem(se.storageKey), this.storage.removeItem(ie.storageKey), this.storage.removeItem(ae.storageKey)
    }
    async generateKeyPair() {
        const e = await (0, ne.generateKeyPair)();
        this.ownPrivateKey = e.privateKey, this.ownPublicKey = e.publicKey, await this.storeKey(ie, e.privateKey), await this.storeKey(se, e.publicKey)
    }
    async loadKeysIfNeeded() {
        if (null === this.ownPrivateKey && (this.ownPrivateKey = await this.loadKey(ie)), null === this.ownPublicKey && (this.ownPublicKey = await this.loadKey(se)), null !== this.ownPrivateKey && null !== this.ownPublicKey || await this.generateKeyPair(), null === this.peerPublicKey && (this.peerPublicKey = await this.loadKey(ae)), null === this.sharedSecret) {
            if (null === this.ownPrivateKey || null === this.peerPublicKey) return;
            this.sharedSecret = await (0, ne.deriveSharedSecret)(this.ownPrivateKey, this.peerPublicKey)
        }
    }
    async loadKey(e) {
        const t = this.storage.getItem(e.storageKey);
        return t ? (0, ne.importKeyFromHexString)(e.keyType, t) : null
    }
    async storeKey(e, t) {
        const n = await (0, ne.exportKeyToHexString)(e.keyType, t);
        this.storage.setItem(e.storageKey, n)
    }
};
var oe = {};
Object.defineProperty(oe, "__esModule", {
    value: !0
}), oe.SCWStateManager = void 0;
const ce = ee,
    le = "accounts",
    ue = "activeChain",
    de = "availableChains",
    he = "walletCapabilities";
oe.SCWStateManager = class {
    get accounts() {
        return this._accounts
    }
    get activeChain() {
        return this._activeChain
    }
    get walletCapabilities() {
        return this._walletCapabilities
    }
    constructor(e) {
        var t, n;
        this.storage = new ce.ScopedLocalStorage("CBWSDK", "SCWStateManager"), this.updateListener = e.updateListener, this.availableChains = this.loadItemFromStorage(de), this._walletCapabilities = this.loadItemFromStorage(he);
        const r = this.loadItemFromStorage(le),
            i = this.loadItemFromStorage(ue);
        r && this.updateListener.onAccountsUpdate({
            accounts: r,
            source: "storage"
        }), i && this.updateListener.onChainUpdate({
            chain: i,
            source: "storage"
        }), this._accounts = r || [], this._activeChain = i || {
            id: null !== (n = null === (t = e.appChainIds) || void 0 === t ? void 0 : t[0]) && void 0 !== n ? n : 1
        }
    }
    updateAccounts(e) {
        this._accounts = e, this.storeItemToStorage(le, e), this.updateListener.onAccountsUpdate({
            accounts: e,
            source: "wallet"
        })
    }
    switchChain(e) {
        var t;
        const n = null === (t = this.availableChains) || void 0 === t ? void 0 : t.find((t => t.id === e));
        return !!n && (n === this._activeChain || (this._activeChain = n, this.storeItemToStorage(ue, n), this.updateListener.onChainUpdate({
            chain: n,
            source: "wallet"
        })), !0)
    }
    updateAvailableChains(e) {
        if (!e || 0 === Object.keys(e).length) return;
        const t = Object.entries(e).map((([e, t]) => ({
            id: Number(e),
            rpcUrl: t
        })));
        this.availableChains = t, this.storeItemToStorage(de, t), this.switchChain(this._activeChain.id)
    }
    updateWalletCapabilities(e) {
        this._walletCapabilities = e, this.storeItemToStorage(he, e)
    }
    storeItemToStorage(e, t) {
        this.storage.setItem(e, JSON.stringify(t))
    }
    loadItemFromStorage(e) {
        const t = this.storage.getItem(e);
        return t ? JSON.parse(t) : void 0
    }
    clear() {
        this.storage.clear()
    }
}, Object.defineProperty(Z, "__esModule", {
    value: !0
}), Z.SCWSigner = void 0;
const fe = G,
    pe = oe,
    _e = h,
    ge = P,
    me = $;
Z.SCWSigner = class {
    constructor(e) {
        this.metadata = e.metadata, this.communicator = e.communicator, this.keyManager = new fe.SCWKeyManager, this.stateManager = new pe.SCWStateManager({
            appChainIds: this.metadata.appChainIds,
            updateListener: e.updateListener
        }), this.handshake = this.handshake.bind(this), this.request = this.request.bind(this), this.createRequestMessage = this.createRequestMessage.bind(this), this.decryptResponseMessage = this.decryptResponseMessage.bind(this)
    }
    async handshake() {
        const e = await this.createRequestMessage({
                handshake: {
                    method: "eth_requestAccounts",
                    params: this.metadata
                }
            }),
            t = await this.communicator.postRequestAndWaitForResponse(e);
        if ("failure" in t.content) throw t.content.failure;
        const n = await (0, me.importKeyFromHexString)("public", t.sender);
        await this.keyManager.setPeerPublicKey(n);
        const r = await this.decryptResponseMessage(t);
        this.updateInternalState({
            method: "eth_requestAccounts"
        }, r);
        const i = r.result;
        if ("error" in i) throw i.error;
        return this.stateManager.accounts
    }
    async request(e) {
        const t = this.tryLocalHandling(e);
        if (void 0 !== t) {
            if (t instanceof Error) throw t;
            return t
        }
        await this.communicator.waitForPopupLoaded();
        const n = await this.sendEncryptedRequest(e),
            r = await this.decryptResponseMessage(n);
        this.updateInternalState(e, r);
        const i = r.result;
        if ("error" in i) throw i.error;
        return i.value
    }
    async disconnect() {
        this.stateManager.clear(), await this.keyManager.clear()
    }
    tryLocalHandling(e) {
        var t;
        switch (e.method) {
            case "wallet_switchEthereumChain":
                {
                    const n = e.params;
                    if (!n || !(null === (t = n[0]) || void 0 === t ? void 0 : t.chainId)) throw _e.standardErrors.rpc.invalidParams();
                    const r = (0, ge.ensureIntNumber)(n[0].chainId);
                    return this.stateManager.switchChain(r) ? null : void 0
                }
            case "wallet_getCapabilities":
                {
                    const e = this.stateManager.walletCapabilities;
                    if (!e) throw _e.standardErrors.provider.unauthorized("No wallet capabilities found, please disconnect and reconnect");
                    return e
                }
            default:
                return
        }
    }
    async sendEncryptedRequest(e) {
        const t = await this.keyManager.getSharedSecret();
        if (!t) throw _e.standardErrors.provider.unauthorized("No valid session found, try requestAccounts before other methods");
        const n = await (0, me.encryptContent)({
                action: e,
                chainId: this.stateManager.activeChain.id
            }, t),
            r = await this.createRequestMessage({
                encrypted: n
            });
        return this.communicator.postRequestAndWaitForResponse(r)
    }
    async createRequestMessage(e) {
        const t = await (0, me.exportKeyToHexString)("public", await this.keyManager.getOwnPublicKey());
        return {
            id: crypto.randomUUID(),
            sender: t,
            content: e,
            timestamp: new Date
        }
    }
    async decryptResponseMessage(e) {
        const t = e.content;
        if ("failure" in t) throw t.failure;
        const n = await this.keyManager.getSharedSecret();
        if (!n) throw _e.standardErrors.provider.unauthorized("Invalid session");
        return (0, me.decryptContent)(t.encrypted, n)
    }
    updateInternalState(e, t) {
        var n, r;
        const i = null === (n = t.data) || void 0 === n ? void 0 : n.chains;
        i && this.stateManager.updateAvailableChains(i);
        const s = null === (r = t.data) || void 0 === r ? void 0 : r.capabilities;
        s && this.stateManager.updateWalletCapabilities(s);
        const a = t.result;
        if (!("error" in a)) switch (e.method) {
            case "eth_requestAccounts":
                {
                    const e = a.value;this.stateManager.updateAccounts(e);
                    break
                }
            case "wallet_switchEthereumChain":
                {
                    if (null !== a.value) return;
                    const t = e.params,
                        n = (0, ge.ensureIntNumber)(t[0].chainId);this.stateManager.switchChain(n);
                    break
                }
        }
    }
};
var be, ye, ve = {},
    we = {
        exports: {}
    },
    Ee = i.EventEmitter;

function Se() {
    if (ye) return be;

    function t(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }))), n.push.apply(n, r)
        }
        return n
    }

    function n(e) {
        for (var n = 1; n < arguments.length; n++) {
            var i = null != arguments[n] ? arguments[n] : {};
            n % 2 ? t(Object(i), !0).forEach((function(t) {
                r(e, t, i[t])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : t(Object(i)).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
            }))
        }
        return e
    }

    function r(e, t, n) {
        return (t = a(t)) in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function i(e, t, n) {
        return t && function(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, a(r.key), r)
            }
        }(e.prototype, t), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e
    }

    function a(e) {
        var t = function(e, t) {
            if ("object" != typeof e || null === e) return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t || "default");
                if ("object" != typeof r) return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }(e, "string");
        return "symbol" == typeof t ? t : String(t)
    }
    ye = 1;
    var o = e.Buffer,
        c = s.inspect,
        l = c && c.custom || "inspect";
    return be = function() {
        function e() {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.head = null, this.tail = null, this.length = 0
        }
        return i(e, [{
            key: "push",
            value: function(e) {
                var t = {
                    data: e,
                    next: null
                };
                this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length
            }
        }, {
            key: "unshift",
            value: function(e) {
                var t = {
                    data: e,
                    next: this.head
                };
                0 === this.length && (this.tail = t), this.head = t, ++this.length
            }
        }, {
            key: "shift",
            value: function() {
                if (0 !== this.length) {
                    var e = this.head.data;
                    return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e
                }
            }
        }, {
            key: "clear",
            value: function() {
                this.head = this.tail = null, this.length = 0
            }
        }, {
            key: "join",
            value: function(e) {
                if (0 === this.length) return "";
                for (var t = this.head, n = "" + t.data; t = t.next;) n += e + t.data;
                return n
            }
        }, {
            key: "concat",
            value: function(e) {
                if (0 === this.length) return o.alloc(0);
                for (var t, n, r, i = o.allocUnsafe(e >>> 0), s = this.head, a = 0; s;) t = s.data, n = i, r = a, o.prototype.copy.call(t, n, r), a += s.data.length, s = s.next;
                return i
            }
        }, {
            key: "consume",
            value: function(e, t) {
                var n;
                return e < this.head.data.length ? (n = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : n = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), n
            }
        }, {
            key: "first",
            value: function() {
                return this.head.data
            }
        }, {
            key: "_getString",
            value: function(e) {
                var t = this.head,
                    n = 1,
                    r = t.data;
                for (e -= r.length; t = t.next;) {
                    var i = t.data,
                        s = e > i.length ? i.length : e;
                    if (s === i.length ? r += i : r += i.slice(0, e), 0 === (e -= s)) {
                        s === i.length ? (++n, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(s));
                        break
                    }++n
                }
                return this.length -= n, r
            }
        }, {
            key: "_getBuffer",
            value: function(e) {
                var t = o.allocUnsafe(e),
                    n = this.head,
                    r = 1;
                for (n.data.copy(t), e -= n.data.length; n = n.next;) {
                    var i = n.data,
                        s = e > i.length ? i.length : e;
                    if (i.copy(t, t.length - e, 0, s), 0 === (e -= s)) {
                        s === i.length ? (++r, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = i.slice(s));
                        break
                    }++r
                }
                return this.length -= r, t
            }
        }, {
            key: l,
            value: function(e, t) {
                return c(this, n(n({}, t), {}, {
                    depth: 0,
                    customInspect: !1
                }))
            }
        }]), e
    }()
}

function ke(e, t) {
    Ie(e, t), Ce(e)
}

function Ce(e) {
    e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close")
}

function Ie(e, t) {
    e.emit("error", t)
}
var Me = {
        destroy: function(e, t) {
            var n = this,
                r = this._readableState && this._readableState.destroyed,
                i = this._writableState && this._writableState.destroyed;
            return r || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(Ie, this, e)) : process.nextTick(Ie, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, (function(e) {
                !t && e ? n._writableState ? n._writableState.errorEmitted ? process.nextTick(Ce, n) : (n._writableState.errorEmitted = !0, process.nextTick(ke, n, e)) : process.nextTick(ke, n, e) : t ? (process.nextTick(Ce, n), t(e)) : process.nextTick(Ce, n)
            })), this)
        },
        undestroy: function() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
        },
        errorOrDestroy: function(e, t) {
            var n = e._readableState,
                r = e._writableState;
            n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit("error", t)
        }
    },
    Re = {};
var xe = {};

function Le(e, t, n) {
    n || (n = Error);
    var r = function(e) {
        var n, r;

        function i(n, r, i) {
            return e.call(this, function(e, n, r) {
                return "string" == typeof t ? t : t(e, n, r)
            }(n, r, i)) || this
        }
        return r = e, (n = i).prototype = Object.create(r.prototype), n.prototype.constructor = n, n.__proto__ = r, i
    }(n);
    r.prototype.name = n.name, r.prototype.code = e, xe[e] = r
}

function Ae(e, t) {
    if (Array.isArray(e)) {
        var n = e.length;
        return e = e.map((function(e) {
            return String(e)
        })), n > 2 ? "one of ".concat(t, " ").concat(e.slice(0, n - 1).join(", "), ", or ") + e[n - 1] : 2 === n ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0])
    }
    return "of ".concat(t, " ").concat(String(e))
}
Le("ERR_INVALID_OPT_VALUE", (function(e, t) {
    return 'The value "' + t + '" is invalid for option "' + e + '"'
}), TypeError), Le("ERR_INVALID_ARG_TYPE", (function(e, t, n) {
    var r, i, s;
    if ("string" == typeof t && (i = "not ", t.substr(0, i.length) === i) ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be", function(e, t, n) {
            return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t
        }(e, " argument")) s = "The ".concat(e, " ").concat(r, " ").concat(Ae(t, "type"));
    else {
        var a = function(e, t, n) {
            return "number" != typeof n && (n = 0), !(n + t.length > e.length) && -1 !== e.indexOf(t, n)
        }(e, ".") ? "property" : "argument";
        s = 'The "'.concat(e, '" ').concat(a, " ").concat(r, " ").concat(Ae(t, "type"))
    }
    return s += ". Received type ".concat(typeof n)
}), TypeError), Le("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Le("ERR_METHOD_NOT_IMPLEMENTED", (function(e) {
    return "The " + e + " method is not implemented"
})), Le("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Le("ERR_STREAM_DESTROYED", (function(e) {
    return "Cannot call " + e + " after a stream was destroyed"
})), Le("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Le("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Le("ERR_STREAM_WRITE_AFTER_END", "write after end"), Le("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Le("ERR_UNKNOWN_ENCODING", (function(e) {
    return "Unknown encoding: " + e
}), TypeError), Le("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Re.codes = xe;
var Pe = Re.codes.ERR_INVALID_OPT_VALUE;
var Te = {
        getHighWaterMark: function(e, t, n, r) {
            var i = function(e, t, n) {
                return null != e.highWaterMark ? e.highWaterMark : t ? e[n] : null
            }(t, r, n);
            if (null != i) {
                if (!isFinite(i) || Math.floor(i) !== i || i < 0) throw new Pe(r ? n : "highWaterMark", i);
                return Math.floor(i)
            }
            return e.objectMode ? 16 : 16384
        }
    },
    je = {
        exports: {}
    };
"function" == typeof Object.create ? je.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
} : je.exports = function(e, t) {
    if (t) {
        e.super_ = t;
        var n = function() {};
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
    }
};
var Ne, Oe, De, Be, Ue = je.exports,
    We = function(e, t) {
        if (qe("noDeprecation")) return e;
        var n = !1;
        return function() {
            if (!n) {
                if (qe("throwDeprecation")) throw new Error(t);
                qe("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0
            }
            return e.apply(this, arguments)
        }
    };

function qe(e) {
    try {
        if (!t.localStorage) return !1
    } catch (r) {
        return !1
    }
    var n = t.localStorage[e];
    return null != n && "true" === String(n).toLowerCase()
}

function He() {
    if (Oe) return Ne;

    function n(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            ! function(e, t, n) {
                var r = e.entry;
                e.entry = null;
                for (; r;) {
                    var i = r.callback;
                    t.pendingcb--, i(n), r = r.next
                }
                t.corkedRequestsFree.next = e
            }(t, e)
        }
    }
    var r;
    Oe = 1, Ne = S, S.WritableState = E;
    var i = {
            deprecate: We
        },
        s = Ee,
        a = e.Buffer,
        o = (void 0 !== t ? t : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {};
    var c, l = Me,
        u = Te.getHighWaterMark,
        d = Re.codes,
        h = d.ERR_INVALID_ARG_TYPE,
        f = d.ERR_METHOD_NOT_IMPLEMENTED,
        p = d.ERR_MULTIPLE_CALLBACK,
        _ = d.ERR_STREAM_CANNOT_PIPE,
        g = d.ERR_STREAM_DESTROYED,
        m = d.ERR_STREAM_NULL_VALUES,
        b = d.ERR_STREAM_WRITE_AFTER_END,
        y = d.ERR_UNKNOWN_ENCODING,
        v = l.errorOrDestroy;

    function w() {}

    function E(e, t, i) {
        r = r || Fe(), e = e || {}, "boolean" != typeof i && (i = t instanceof r), this.objectMode = !!e.objectMode, i && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = u(this, e, "writableHighWaterMark", i), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var s = !1 === e.decodeStrings;
        this.decodeStrings = !s, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
            ! function(e, t) {
                var n = e._writableState,
                    r = n.sync,
                    i = n.writecb;
                if ("function" != typeof i) throw new p;
                if (function(e) {
                        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
                    }(n), t) ! function(e, t, n, r, i) {
                    --t.pendingcb, n ? (process.nextTick(i, r), process.nextTick(x, e, t), e._writableState.errorEmitted = !0, v(e, r)) : (i(r), e._writableState.errorEmitted = !0, v(e, r), x(e, t))
                }(e, n, r, t, i);
                else {
                    var s = M(n) || e.destroyed;
                    s || n.corked || n.bufferProcessing || !n.bufferedRequest || I(e, n), r ? process.nextTick(C, e, n, s, i) : C(e, n, s, i)
                }
            }(t, e)
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this)
    }

    function S(e) {
        var t = this instanceof(r = r || Fe());
        if (!t && !c.call(S, this)) return new S(e);
        this._writableState = new E(e, this, t), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), s.call(this)
    }

    function k(e, t, n, r, i, s, a) {
        t.writelen = r, t.writecb = a, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new g("write")) : n ? e._writev(i, t.onwrite) : e._write(i, s, t.onwrite), t.sync = !1
    }

    function C(e, t, n, r) {
        n || function(e, t) {
            0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
        }(e, t), t.pendingcb--, r(), x(e, t)
    }

    function I(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount,
                s = new Array(i),
                a = t.corkedRequestsFree;
            a.entry = r;
            for (var o = 0, c = !0; r;) s[o] = r, r.isBuf || (c = !1), r = r.next, o += 1;
            s.allBuffers = c, k(e, t, !0, t.length, s, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new n(t), t.bufferedRequestCount = 0
        } else {
            for (; r;) {
                var l = r.chunk,
                    u = r.encoding,
                    d = r.callback;
                if (k(e, t, !1, t.objectMode ? 1 : l.length, l, u, d), r = r.next, t.bufferedRequestCount--, t.writing) break
            }
            null === r && (t.lastBufferedRequest = null)
        }
        t.bufferedRequest = r, t.bufferProcessing = !1
    }

    function M(e) {
        return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
    }

    function R(e, t) {
        e._final((function(n) {
            t.pendingcb--, n && v(e, n), t.prefinished = !0, e.emit("prefinish"), x(e, t)
        }))
    }

    function x(e, t) {
        var n = M(t);
        if (n && (function(e, t) {
                t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, process.nextTick(R, e, t)))
            }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var r = e._readableState;
            (!r || r.autoDestroy && r.endEmitted) && e.destroy()
        }
        return n
    }
    return Ue(S, s), E.prototype.getBuffer = function() {
            for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
            return t
        },
        function() {
            try {
                Object.defineProperty(E.prototype, "buffer", {
                    get: i.deprecate((function() {
                        return this.getBuffer()
                    }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                })
            } catch (e) {}
        }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c = Function.prototype[Symbol.hasInstance], Object.defineProperty(S, Symbol.hasInstance, {
            value: function(e) {
                return !!c.call(this, e) || this === S && (e && e._writableState instanceof E)
            }
        })) : c = function(e) {
            return e instanceof this
        }, S.prototype.pipe = function() {
            v(this, new _)
        }, S.prototype.write = function(e, t, n) {
            var r, i = this._writableState,
                s = !1,
                c = !i.objectMode && (r = e, a.isBuffer(r) || r instanceof o);
            return c && !a.isBuffer(e) && (e = function(e) {
                return a.from(e)
            }(e)), "function" == typeof t && (n = t, t = null), c ? t = "buffer" : t || (t = i.defaultEncoding), "function" != typeof n && (n = w), i.ending ? function(e, t) {
                var n = new b;
                v(e, n), process.nextTick(t, n)
            }(this, n) : (c || function(e, t, n, r) {
                var i;
                return null === n ? i = new m : "string" == typeof n || t.objectMode || (i = new h("chunk", ["string", "Buffer"], n)), !i || (v(e, i), process.nextTick(r, i), !1)
            }(this, i, e, n)) && (i.pendingcb++, s = function(e, t, n, r, i, s) {
                if (!n) {
                    var o = function(e, t, n) {
                        e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = a.from(t, n));
                        return t
                    }(t, r, i);
                    r !== o && (n = !0, i = "buffer", r = o)
                }
                var c = t.objectMode ? 1 : r.length;
                t.length += c;
                var l = t.length < t.highWaterMark;
                l || (t.needDrain = !0);
                if (t.writing || t.corked) {
                    var u = t.lastBufferedRequest;
                    t.lastBufferedRequest = {
                        chunk: r,
                        encoding: i,
                        isBuf: n,
                        callback: s,
                        next: null
                    }, u ? u.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
                } else k(e, t, !1, c, r, i, s);
                return l
            }(this, i, c, e, t, n)), s
        }, S.prototype.cork = function() {
            this._writableState.corked++
        }, S.prototype.uncork = function() {
            var e = this._writableState;
            e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || I(this, e))
        }, S.prototype.setDefaultEncoding = function(e) {
            if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new y(e);
            return this._writableState.defaultEncoding = e, this
        }, Object.defineProperty(S.prototype, "writableBuffer", {
            enumerable: !1,
            get: function() {
                return this._writableState && this._writableState.getBuffer()
            }
        }), Object.defineProperty(S.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function() {
                return this._writableState.highWaterMark
            }
        }), S.prototype._write = function(e, t, n) {
            n(new f("_write()"))
        }, S.prototype._writev = null, S.prototype.end = function(e, t, n) {
            var r = this._writableState;
            return "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null != e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || function(e, t, n) {
                t.ending = !0, x(e, t), n && (t.finished ? process.nextTick(n) : e.once("finish", n));
                t.ended = !0, e.writable = !1
            }(this, r, n), this
        }, Object.defineProperty(S.prototype, "writableLength", {
            enumerable: !1,
            get: function() {
                return this._writableState.length
            }
        }), Object.defineProperty(S.prototype, "destroyed", {
            enumerable: !1,
            get: function() {
                return void 0 !== this._writableState && this._writableState.destroyed
            },
            set: function(e) {
                this._writableState && (this._writableState.destroyed = e)
            }
        }), S.prototype.destroy = l.destroy, S.prototype._undestroy = l.undestroy, S.prototype._destroy = function(e, t) {
            t(e)
        }, Ne
}

function Fe() {
    if (Be) return De;
    Be = 1;
    var e = Object.keys || function(e) {
        var t = [];
        for (var n in e) t.push(n);
        return t
    };
    De = a;
    var t = st(),
        n = He();
    Ue(a, t);
    for (var r = e(n.prototype), i = 0; i < r.length; i++) {
        var s = r[i];
        a.prototype[s] || (a.prototype[s] = n.prototype[s])
    }

    function a(e) {
        if (!(this instanceof a)) return new a(e);
        t.call(this, e), n.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", o)))
    }

    function o() {
        this._writableState.ended || process.nextTick(c, this)
    }

    function c(e) {
        e.end()
    }
    return Object.defineProperty(a.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    }), Object.defineProperty(a.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    }), Object.defineProperty(a.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    }), Object.defineProperty(a.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
        },
        set: function(e) {
            void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
        }
    }), De
}
var ze = {},
    Ve = {
        exports: {}
    };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
! function(t, n) {
    var r = e,
        i = r.Buffer;

    function s(e, t) {
        for (var n in e) t[n] = e[n]
    }

    function a(e, t, n) {
        return i(e, t, n)
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = r : (s(r, n), n.Buffer = a), a.prototype = Object.create(i.prototype), s(i, a), a.from = function(e, t, n) {
        if ("number" == typeof e) throw new TypeError("Argument must not be a number");
        return i(e, t, n)
    }, a.alloc = function(e, t, n) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        var r = i(e);
        return void 0 !== t ? "string" == typeof n ? r.fill(t, n) : r.fill(t) : r.fill(0), r
    }, a.allocUnsafe = function(e) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        return i(e)
    }, a.allocUnsafeSlow = function(e) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        return r.SlowBuffer(e)
    }
}(Ve, Ve.exports);
var Ke, Ze = Ve.exports;

function Ge() {
    if (Ke) return ze;
    Ke = 1;
    var e = Ze.Buffer,
        t = e.isEncoding || function(e) {
            switch ((e = "" + e) && e.toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                    return !0;
                default:
                    return !1
            }
        };

    function n(n) {
        var r;
        switch (this.encoding = function(n) {
            var r = function(e) {
                if (!e) return "utf8";
                for (var t;;) switch (e) {
                    case "utf8":
                    case "utf-8":
                        return "utf8";
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return "utf16le";
                    case "latin1":
                    case "binary":
                        return "latin1";
                    case "base64":
                    case "ascii":
                    case "hex":
                        return e;
                    default:
                        if (t) return;
                        e = ("" + e).toLowerCase(), t = !0
                }
            }(n);
            if ("string" != typeof r && (e.isEncoding === t || !t(n))) throw new Error("Unknown encoding: " + n);
            return r || n
        }(n), this.encoding) {
            case "utf16le":
                this.text = s, this.end = a, r = 4;
                break;
            case "utf8":
                this.fillLast = i, r = 4;
                break;
            case "base64":
                this.text = o, this.end = c, r = 3;
                break;
            default:
                return this.write = l, void(this.end = u)
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(r)
    }

    function r(e) {
        return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2
    }

    function i(e) {
        var t = this.lastTotal - this.lastNeed,
            n = function(e, t) {
                if (128 != (192 & t[0])) return e.lastNeed = 0, "�";
                if (e.lastNeed > 1 && t.length > 1) {
                    if (128 != (192 & t[1])) return e.lastNeed = 1, "�";
                    if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2])) return e.lastNeed = 2, "�"
                }
            }(this, e);
        return void 0 !== n ? n : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), void(this.lastNeed -= e.length))
    }

    function s(e, t) {
        if ((e.length - t) % 2 == 0) {
            var n = e.toString("utf16le", t);
            if (n) {
                var r = n.charCodeAt(n.length - 1);
                if (r >= 55296 && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], n.slice(0, -1)
            }
            return n
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1)
    }

    function a(e) {
        var t = e && e.length ? this.write(e) : "";
        if (this.lastNeed) {
            var n = this.lastTotal - this.lastNeed;
            return t + this.lastChar.toString("utf16le", 0, n)
        }
        return t
    }

    function o(e, t) {
        var n = (e.length - t) % 3;
        return 0 === n ? e.toString("base64", t) : (this.lastNeed = 3 - n, this.lastTotal = 3, 1 === n ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - n))
    }

    function c(e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t
    }

    function l(e) {
        return e.toString(this.encoding)
    }

    function u(e) {
        return e && e.length ? this.write(e) : ""
    }
    return ze.StringDecoder = n, n.prototype.write = function(e) {
        if (0 === e.length) return "";
        var t, n;
        if (this.lastNeed) {
            if (void 0 === (t = this.fillLast(e))) return "";
            n = this.lastNeed, this.lastNeed = 0
        } else n = 0;
        return n < e.length ? t ? t + this.text(e, n) : this.text(e, n) : t || ""
    }, n.prototype.end = function(e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + "�" : t
    }, n.prototype.text = function(e, t) {
        var n = function(e, t, n) {
            var i = t.length - 1;
            if (i < n) return 0;
            var s = r(t[i]);
            if (s >= 0) return s > 0 && (e.lastNeed = s - 1), s;
            if (--i < n || -2 === s) return 0;
            if (s = r(t[i]), s >= 0) return s > 0 && (e.lastNeed = s - 2), s;
            if (--i < n || -2 === s) return 0;
            if (s = r(t[i]), s >= 0) return s > 0 && (2 === s ? s = 0 : e.lastNeed = s - 3), s;
            return 0
        }(this, e, t);
        if (!this.lastNeed) return e.toString("utf8", t);
        this.lastTotal = n;
        var i = e.length - (n - this.lastNeed);
        return e.copy(this.lastChar, 0, i), e.toString("utf8", t, i)
    }, n.prototype.fillLast = function(e) {
        if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length
    }, ze
}
var $e = Re.codes.ERR_STREAM_PREMATURE_CLOSE;

function Ye() {}
var Je, Qe, Xe, et, tt, nt, rt = function e(t, n, r) {
    if ("function" == typeof n) return e(t, null, n);
    n || (n = {}), r = function(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
                e.apply(this, r)
            }
        }
    }(r || Ye);
    var i = n.readable || !1 !== n.readable && t.readable,
        s = n.writable || !1 !== n.writable && t.writable,
        a = function() {
            t.writable || c()
        },
        o = t._writableState && t._writableState.finished,
        c = function() {
            s = !1, o = !0, i || r.call(t)
        },
        l = t._readableState && t._readableState.endEmitted,
        u = function() {
            i = !1, l = !0, s || r.call(t)
        },
        d = function(e) {
            r.call(t, e)
        },
        h = function() {
            var e;
            return i && !l ? (t._readableState && t._readableState.ended || (e = new $e), r.call(t, e)) : s && !o ? (t._writableState && t._writableState.ended || (e = new $e), r.call(t, e)) : void 0
        },
        f = function() {
            t.req.on("finish", c)
        };
    return ! function(e) {
            return e.setHeader && "function" == typeof e.abort
        }(t) ? s && !t._writableState && (t.on("end", a), t.on("close", a)) : (t.on("complete", c), t.on("abort", h), t.req ? f() : t.on("request", f)), t.on("end", u), t.on("finish", c), !1 !== n.error && t.on("error", d), t.on("close", h),
        function() {
            t.removeListener("complete", c), t.removeListener("abort", h), t.removeListener("request", f), t.req && t.req.removeListener("finish", c), t.removeListener("end", a), t.removeListener("close", a), t.removeListener("finish", c), t.removeListener("end", u), t.removeListener("error", d), t.removeListener("close", h)
        }
};

function it() {
    if (Qe) return Je;
    var e;

    function t(e, t, n) {
        return (t = function(e) {
            var t = function(e, t) {
                if ("object" != typeof e || null === e) return e;
                var n = e[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(e, t || "default");
                    if ("object" != typeof r) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === t ? String : Number)(e)
            }(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }(t)) in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }
    Qe = 1;
    var n = rt,
        r = Symbol("lastResolve"),
        i = Symbol("lastReject"),
        s = Symbol("error"),
        a = Symbol("ended"),
        o = Symbol("lastPromise"),
        c = Symbol("handlePromise"),
        l = Symbol("stream");

    function u(e, t) {
        return {
            value: e,
            done: t
        }
    }

    function d(e) {
        var t = e[r];
        if (null !== t) {
            var n = e[l].read();
            null !== n && (e[o] = null, e[r] = null, e[i] = null, t(u(n, !1)))
        }
    }

    function h(e) {
        process.nextTick(d, e)
    }
    var f = Object.getPrototypeOf((function() {})),
        p = Object.setPrototypeOf((t(e = {
            get stream() {
                return this[l]
            },
            next: function() {
                var e = this,
                    t = this[s];
                if (null !== t) return Promise.reject(t);
                if (this[a]) return Promise.resolve(u(void 0, !0));
                if (this[l].destroyed) return new Promise((function(t, n) {
                    process.nextTick((function() {
                        e[s] ? n(e[s]) : t(u(void 0, !0))
                    }))
                }));
                var n, r = this[o];
                if (r) n = new Promise(function(e, t) {
                    return function(n, r) {
                        e.then((function() {
                            t[a] ? n(u(void 0, !0)) : t[c](n, r)
                        }), r)
                    }
                }(r, this));
                else {
                    var i = this[l].read();
                    if (null !== i) return Promise.resolve(u(i, !1));
                    n = new Promise(this[c])
                }
                return this[o] = n, n
            }
        }, Symbol.asyncIterator, (function() {
            return this
        })), t(e, "return", (function() {
            var e = this;
            return new Promise((function(t, n) {
                e[l].destroy(null, (function(e) {
                    e ? n(e) : t(u(void 0, !0))
                }))
            }))
        })), e), f);
    return Je = function(e) {
        var d, f = Object.create(p, (t(d = {}, l, {
            value: e,
            writable: !0
        }), t(d, r, {
            value: null,
            writable: !0
        }), t(d, i, {
            value: null,
            writable: !0
        }), t(d, s, {
            value: null,
            writable: !0
        }), t(d, a, {
            value: e._readableState.endEmitted,
            writable: !0
        }), t(d, c, {
            value: function(e, t) {
                var n = f[l].read();
                n ? (f[o] = null, f[r] = null, f[i] = null, e(u(n, !1))) : (f[r] = e, f[i] = t)
            },
            writable: !0
        }), d));
        return f[o] = null, n(e, (function(e) {
            if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
                var t = f[i];
                return null !== t && (f[o] = null, f[r] = null, f[i] = null, t(e)), void(f[s] = e)
            }
            var n = f[r];
            null !== n && (f[o] = null, f[r] = null, f[i] = null, n(u(void 0, !0))), f[a] = !0
        })), e.on("readable", h.bind(null, f)), f
    }
}

function st() {
    if (nt) return tt;
    var n;
    nt = 1, tt = C, C.ReadableState = k, i.EventEmitter;
    var r = function(e, t) {
            return e.listeners(t).length
        },
        a = Ee,
        o = e.Buffer,
        c = (void 0 !== t ? t : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {};
    var l, u = s;
    l = u && u.debuglog ? u.debuglog("stream") : function() {};
    var d, h, f, p = Se(),
        _ = Me,
        g = Te.getHighWaterMark,
        m = Re.codes,
        b = m.ERR_INVALID_ARG_TYPE,
        y = m.ERR_STREAM_PUSH_AFTER_EOF,
        v = m.ERR_METHOD_NOT_IMPLEMENTED,
        w = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    Ue(C, a);
    var E = _.errorOrDestroy,
        S = ["error", "close", "destroy", "pause", "resume"];

    function k(e, t, r) {
        n = n || Fe(), e = e || {}, "boolean" != typeof r && (r = t instanceof n), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = g(this, e, "readableHighWaterMark", r), this.buffer = new p, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (d || (d = Ge().StringDecoder), this.decoder = new d(e.encoding), this.encoding = e.encoding)
    }

    function C(e) {
        if (n = n || Fe(), !(this instanceof C)) return new C(e);
        var t = this instanceof n;
        this._readableState = new k(e, this, t), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), a.call(this)
    }

    function I(e, t, n, r, i) {
        l("readableAddChunk", t);
        var s, a = e._readableState;
        if (null === t) a.reading = !1,
            function(e, t) {
                if (l("onEofChunk"), t.ended) return;
                if (t.decoder) {
                    var n = t.decoder.end();
                    n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length)
                }
                t.ended = !0, t.sync ? L(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, A(e)))
            }(e, a);
        else if (i || (s = function(e, t) {
                var n;
                r = t, o.isBuffer(r) || r instanceof c || "string" == typeof t || void 0 === t || e.objectMode || (n = new b("chunk", ["string", "Buffer", "Uint8Array"], t));
                var r;
                return n
            }(a, t)), s) E(e, s);
        else if (a.objectMode || t && t.length > 0)
            if ("string" == typeof t || a.objectMode || Object.getPrototypeOf(t) === o.prototype || (t = function(e) {
                    return o.from(e)
                }(t)), r) a.endEmitted ? E(e, new w) : M(e, a, t, !0);
            else if (a.ended) E(e, new y);
        else {
            if (a.destroyed) return !1;
            a.reading = !1, a.decoder && !n ? (t = a.decoder.write(t), a.objectMode || 0 !== t.length ? M(e, a, t, !1) : P(e, a)) : M(e, a, t, !1)
        } else r || (a.reading = !1, P(e, a));
        return !a.ended && (a.length < a.highWaterMark || 0 === a.length)
    }

    function M(e, t, n, r) {
        t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && L(e)), P(e, t)
    }
    Object.defineProperty(C.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return void 0 !== this._readableState && this._readableState.destroyed
        },
        set: function(e) {
            this._readableState && (this._readableState.destroyed = e)
        }
    }), C.prototype.destroy = _.destroy, C.prototype._undestroy = _.undestroy, C.prototype._destroy = function(e, t) {
        t(e)
    }, C.prototype.push = function(e, t) {
        var n, r = this._readableState;
        return r.objectMode ? n = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = o.from(e, t), t = ""), n = !0), I(this, e, t, !1, n)
    }, C.prototype.unshift = function(e) {
        return I(this, e, null, !0, !1)
    }, C.prototype.isPaused = function() {
        return !1 === this._readableState.flowing
    }, C.prototype.setEncoding = function(e) {
        d || (d = Ge().StringDecoder);
        var t = new d(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var n = this._readableState.buffer.head, r = ""; null !== n;) r += t.write(n.data), n = n.next;
        return this._readableState.buffer.clear(), "" !== r && this._readableState.buffer.push(r), this._readableState.length = r.length, this
    };
    var R = 1073741824;

    function x(e, t) {
        return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {
            return e >= R ? e = R : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
        }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
    }

    function L(e) {
        var t = e._readableState;
        l("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (l("emitReadable", t.flowing), t.emittedReadable = !0, process.nextTick(A, e))
    }

    function A(e) {
        var t = e._readableState;
        l("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, D(e)
    }

    function P(e, t) {
        t.readingMore || (t.readingMore = !0, process.nextTick(T, e, t))
    }

    function T(e, t) {
        for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
            var n = t.length;
            if (l("maybeReadMore read 0"), e.read(0), n === t.length) break
        }
        t.readingMore = !1
    }

    function j(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume()
    }

    function N(e) {
        l("readable nexttick read 0"), e.read(0)
    }

    function O(e, t) {
        l("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), D(e), t.flowing && !t.reading && e.read(0)
    }

    function D(e) {
        var t = e._readableState;
        for (l("flow", t.flowing); t.flowing && null !== e.read(););
    }

    function B(e, t) {
        return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n);
        var n
    }

    function U(e) {
        var t = e._readableState;
        l("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, process.nextTick(W, t, e))
    }

    function W(e, t) {
        if (l("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var n = t._writableState;
            (!n || n.autoDestroy && n.finished) && t.destroy()
        }
    }

    function q(e, t) {
        for (var n = 0, r = e.length; n < r; n++)
            if (e[n] === t) return n;
        return -1
    }
    return C.prototype.read = function(e) {
        l("read", e), e = parseInt(e, 10);
        var t = this._readableState,
            n = e;
        if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return l("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? U(this) : L(this), null;
        if (0 === (e = x(e, t)) && t.ended) return 0 === t.length && U(this), null;
        var r, i = t.needReadable;
        return l("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && l("length less than watermark", i = !0), t.ended || t.reading ? l("reading or ended", i = !1) : i && (l("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = x(n, t))), null === (r = e > 0 ? B(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && U(this)), null !== r && this.emit("data", r), r
    }, C.prototype._read = function(e) {
        E(this, new v("_read()"))
    }, C.prototype.pipe = function(e, t) {
        var n = this,
            i = this._readableState;
        switch (i.pipesCount) {
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [i.pipes, e];
                break;
            default:
                i.pipes.push(e)
        }
        i.pipesCount += 1, l("pipe count=%d opts=%j", i.pipesCount, t);
        var s = (!t || !1 !== t.end) && e !== process.stdout && e !== process.stderr ? o : _;

        function a(t, r) {
            l("onunpipe"), t === n && r && !1 === r.hasUnpiped && (r.hasUnpiped = !0, l("cleanup"), e.removeListener("close", f), e.removeListener("finish", p), e.removeListener("drain", c), e.removeListener("error", h), e.removeListener("unpipe", a), n.removeListener("end", o), n.removeListener("end", _), n.removeListener("data", d), u = !0, !i.awaitDrain || e._writableState && !e._writableState.needDrain || c())
        }

        function o() {
            l("onend"), e.end()
        }
        i.endEmitted ? process.nextTick(s) : n.once("end", s), e.on("unpipe", a);
        var c = function(e) {
            return function() {
                var t = e._readableState;
                l("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && r(e, "data") && (t.flowing = !0, D(e))
            }
        }(n);
        e.on("drain", c);
        var u = !1;

        function d(t) {
            l("ondata");
            var r = e.write(t);
            l("dest.write", r), !1 === r && ((1 === i.pipesCount && i.pipes === e || i.pipesCount > 1 && -1 !== q(i.pipes, e)) && !u && (l("false write response, pause", i.awaitDrain), i.awaitDrain++), n.pause())
        }

        function h(t) {
            l("onerror", t), _(), e.removeListener("error", h), 0 === r(e, "error") && E(e, t)
        }

        function f() {
            e.removeListener("finish", p), _()
        }

        function p() {
            l("onfinish"), e.removeListener("close", f), _()
        }

        function _() {
            l("unpipe"), n.unpipe(e)
        }
        return n.on("data", d),
            function(e, t, n) {
                if ("function" == typeof e.prependListener) return e.prependListener(t, n);
                e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n)
            }(e, "error", h), e.once("close", f), e.once("finish", p), e.emit("pipe", n), i.flowing || (l("pipe resume"), n.resume()), e
    }, C.prototype.unpipe = function(e) {
        var t = this._readableState,
            n = {
                hasUnpiped: !1
            };
        if (0 === t.pipesCount) return this;
        if (1 === t.pipesCount) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n)), this;
        if (!e) {
            var r = t.pipes,
                i = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for (var s = 0; s < i; s++) r[s].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this
        }
        var a = q(t.pipes, e);
        return -1 === a || (t.pipes.splice(a, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n)), this
    }, C.prototype.on = function(e, t) {
        var n = a.prototype.on.call(this, e, t),
            r = this._readableState;
        return "data" === e ? (r.readableListening = this.listenerCount("readable") > 0, !1 !== r.flowing && this.resume()) : "readable" === e && (r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.flowing = !1, r.emittedReadable = !1, l("on readable", r.length, r.reading), r.length ? L(this) : r.reading || process.nextTick(N, this))), n
    }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function(e, t) {
        var n = a.prototype.removeListener.call(this, e, t);
        return "readable" === e && process.nextTick(j, this), n
    }, C.prototype.removeAllListeners = function(e) {
        var t = a.prototype.removeAllListeners.apply(this, arguments);
        return "readable" !== e && void 0 !== e || process.nextTick(j, this), t
    }, C.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (l("resume"), e.flowing = !e.readableListening, function(e, t) {
            t.resumeScheduled || (t.resumeScheduled = !0, process.nextTick(O, e, t))
        }(this, e)), e.paused = !1, this
    }, C.prototype.pause = function() {
        return l("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
    }, C.prototype.wrap = function(e) {
        var t = this,
            n = this._readableState,
            r = !1;
        for (var i in e.on("end", (function() {
                if (l("wrapped end"), n.decoder && !n.ended) {
                    var e = n.decoder.end();
                    e && e.length && t.push(e)
                }
                t.push(null)
            })), e.on("data", (function(i) {
                (l("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()))
            })), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
            return function() {
                return e[t].apply(e, arguments)
            }
        }(i));
        for (var s = 0; s < S.length; s++) e.on(S[s], this.emit.bind(this, S[s]));
        return this._read = function(t) {
            l("wrapped _read", t), r && (r = !1, e.resume())
        }, this
    }, "function" == typeof Symbol && (C.prototype[Symbol.asyncIterator] = function() {
        return void 0 === h && (h = it()), h(this)
    }), Object.defineProperty(C.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }), Object.defineProperty(C.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer
        }
    }), Object.defineProperty(C.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing
        },
        set: function(e) {
            this._readableState && (this._readableState.flowing = e)
        }
    }), C._fromList = B, Object.defineProperty(C.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length
        }
    }), "function" == typeof Symbol && (C.from = function(e, t) {
        return void 0 === f && (f = et ? Xe : (et = 1, Xe = function() {
            throw new Error("Readable.from is not available in the browser")
        })), f(C, e, t)
    }), tt
}
var at = pt,
    ot = Re.codes,
    ct = ot.ERR_METHOD_NOT_IMPLEMENTED,
    lt = ot.ERR_MULTIPLE_CALLBACK,
    ut = ot.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    dt = ot.ERR_TRANSFORM_WITH_LENGTH_0,
    ht = Fe();

function ft(e, t) {
    var n = this._transformState;
    n.transforming = !1;
    var r = n.writecb;
    if (null === r) return this.emit("error", new lt);
    n.writechunk = null, n.writecb = null, null != t && this.push(t), r(e);
    var i = this._readableState;
    i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
}

function pt(e) {
    if (!(this instanceof pt)) return new pt(e);
    ht.call(this, e), this._transformState = {
        afterTransform: ft.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", _t)
}

function _t() {
    var e = this;
    "function" != typeof this._flush || this._readableState.destroyed ? gt(this, null, null) : this._flush((function(t, n) {
        gt(e, t, n)
    }))
}

function gt(e, t, n) {
    if (t) return e.emit("error", t);
    if (null != n && e.push(n), e._writableState.length) throw new dt;
    if (e._transformState.transforming) throw new ut;
    return e.push(null)
}
Ue(pt, ht), pt.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, ht.prototype.push.call(this, e, t)
}, pt.prototype._transform = function(e, t, n) {
    n(new ct("_transform()"))
}, pt.prototype._write = function(e, t, n) {
    var r = this._transformState;
    if (r.writecb = n, r.writechunk = e, r.writeencoding = t, !r.transforming) {
        var i = this._readableState;
        (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
    }
}, pt.prototype._read = function(e) {
    var t = this._transformState;
    null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform))
}, pt.prototype._destroy = function(e, t) {
    ht.prototype._destroy.call(this, e, (function(e) {
        t(e)
    }))
};
var mt, bt = vt,
    yt = at;

function vt(e) {
    if (!(this instanceof vt)) return new vt(e);
    yt.call(this, e)
}
Ue(vt, yt), vt.prototype._transform = function(e, t, n) {
    n(null, e)
};
var wt = Re.codes,
    Et = wt.ERR_MISSING_ARGS,
    St = wt.ERR_STREAM_DESTROYED;

function kt(e) {
    if (e) throw e
}

function Ct(e) {
    e()
}

function It(e, t) {
    return e.pipe(t)
}
var Mt, Rt = function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    var r, i = function(e) {
        return e.length ? "function" != typeof e[e.length - 1] ? kt : e.pop() : kt
    }(t);
    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new Et("streams");
    var s = t.map((function(e, n) {
        var a = n < t.length - 1;
        return function(e, t, n, r) {
            r = function(e) {
                var t = !1;
                return function() {
                    t || (t = !0, e.apply(void 0, arguments))
                }
            }(r);
            var i = !1;
            e.on("close", (function() {
                i = !0
            })), void 0 === mt && (mt = rt), mt(e, {
                readable: t,
                writable: n
            }, (function(e) {
                if (e) return r(e);
                i = !0, r()
            }));
            var s = !1;
            return function(t) {
                if (!i && !s) return s = !0,
                    function(e) {
                        return e.setHeader && "function" == typeof e.abort
                    }(e) ? e.abort() : "function" == typeof e.destroy ? e.destroy() : void r(t || new St("pipe"))
            }
        }(e, a, n > 0, (function(e) {
            r || (r = e), e && s.forEach(Ct), a || (s.forEach(Ct), i(r))
        }))
    }));
    return t.reduce(It)
};
Mt = we.exports, (Mt = we.exports = st()).Stream = Mt, Mt.Readable = Mt, Mt.Writable = He(), Mt.Duplex = Fe(), Mt.Transform = at, Mt.PassThrough = bt, Mt.finished = rt, Mt.pipeline = Rt;
var xt = we.exports;
const {
    Transform: Lt
} = xt;
const {
    Transform: At
} = xt;
const Pt = e => class t extends Lt {
        constructor(t, n, r, i, s) {
            super(s), this._rate = t, this._capacity = n, this._delimitedSuffix = r, this._hashBitLength = i, this._options = s, this._state = new e, this._state.initialize(t, n), this._finalized = !1
        }
        _transform(e, t, n) {
            let r = null;
            try {
                this.update(e, t)
            } catch (i) {
                r = i
            }
            n(r)
        }
        _flush(e) {
            let t = null;
            try {
                this.push(this.digest())
            } catch (n) {
                t = n
            }
            e(t)
        }
        update(e, t) {
            if (!Buffer.isBuffer(e) && "string" != typeof e) throw new TypeError("Data must be a string or a buffer");
            if (this._finalized) throw new Error("Digest already called");
            return Buffer.isBuffer(e) || (e = Buffer.from(e, t)), this._state.absorb(e), this
        }
        digest(e) {
            if (this._finalized) throw new Error("Digest already called");
            this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
            let t = this._state.squeeze(this._hashBitLength / 8);
            return void 0 !== e && (t = t.toString(e)), this._resetState(), t
        }
        _resetState() {
            return this._state.initialize(this._rate, this._capacity), this
        }
        _clone() {
            const e = new t(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
            return this._state.copy(e._state), e._finalized = this._finalized, e
        }
    },
    Tt = e => class t extends At {
        constructor(t, n, r, i) {
            super(i), this._rate = t, this._capacity = n, this._delimitedSuffix = r, this._options = i, this._state = new e, this._state.initialize(t, n), this._finalized = !1
        }
        _transform(e, t, n) {
            let r = null;
            try {
                this.update(e, t)
            } catch (i) {
                r = i
            }
            n(r)
        }
        _flush() {}
        _read(e) {
            this.push(this.squeeze(e))
        }
        update(e, t) {
            if (!Buffer.isBuffer(e) && "string" != typeof e) throw new TypeError("Data must be a string or a buffer");
            if (this._finalized) throw new Error("Squeeze already called");
            return Buffer.isBuffer(e) || (e = Buffer.from(e, t)), this._state.absorb(e), this
        }
        squeeze(e, t) {
            this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
            let n = this._state.squeeze(e);
            return void 0 !== t && (n = n.toString(t)), n
        }
        _resetState() {
            return this._state.initialize(this._rate, this._capacity), this
        }
        _clone() {
            const e = new t(this._rate, this._capacity, this._delimitedSuffix, this._options);
            return this._state.copy(e._state), e._finalized = this._finalized, e
        }
    };
var jt = {};
const Nt = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
jt.p1600 = function(e) {
    for (let t = 0; t < 24; ++t) {
        const n = e[0] ^ e[10] ^ e[20] ^ e[30] ^ e[40],
            r = e[1] ^ e[11] ^ e[21] ^ e[31] ^ e[41],
            i = e[2] ^ e[12] ^ e[22] ^ e[32] ^ e[42],
            s = e[3] ^ e[13] ^ e[23] ^ e[33] ^ e[43],
            a = e[4] ^ e[14] ^ e[24] ^ e[34] ^ e[44],
            o = e[5] ^ e[15] ^ e[25] ^ e[35] ^ e[45],
            c = e[6] ^ e[16] ^ e[26] ^ e[36] ^ e[46],
            l = e[7] ^ e[17] ^ e[27] ^ e[37] ^ e[47],
            u = e[8] ^ e[18] ^ e[28] ^ e[38] ^ e[48],
            d = e[9] ^ e[19] ^ e[29] ^ e[39] ^ e[49];
        let h = u ^ (i << 1 | s >>> 31),
            f = d ^ (s << 1 | i >>> 31);
        const p = e[0] ^ h,
            _ = e[1] ^ f,
            g = e[10] ^ h,
            m = e[11] ^ f,
            b = e[20] ^ h,
            y = e[21] ^ f,
            v = e[30] ^ h,
            w = e[31] ^ f,
            E = e[40] ^ h,
            S = e[41] ^ f;
        h = n ^ (a << 1 | o >>> 31), f = r ^ (o << 1 | a >>> 31);
        const k = e[2] ^ h,
            C = e[3] ^ f,
            I = e[12] ^ h,
            M = e[13] ^ f,
            R = e[22] ^ h,
            x = e[23] ^ f,
            L = e[32] ^ h,
            A = e[33] ^ f,
            P = e[42] ^ h,
            T = e[43] ^ f;
        h = i ^ (c << 1 | l >>> 31), f = s ^ (l << 1 | c >>> 31);
        const j = e[4] ^ h,
            N = e[5] ^ f,
            O = e[14] ^ h,
            D = e[15] ^ f,
            B = e[24] ^ h,
            U = e[25] ^ f,
            W = e[34] ^ h,
            q = e[35] ^ f,
            H = e[44] ^ h,
            F = e[45] ^ f;
        h = a ^ (u << 1 | d >>> 31), f = o ^ (d << 1 | u >>> 31);
        const z = e[6] ^ h,
            V = e[7] ^ f,
            K = e[16] ^ h,
            Z = e[17] ^ f,
            G = e[26] ^ h,
            $ = e[27] ^ f,
            Y = e[36] ^ h,
            J = e[37] ^ f,
            Q = e[46] ^ h,
            X = e[47] ^ f;
        h = c ^ (n << 1 | r >>> 31), f = l ^ (r << 1 | n >>> 31);
        const ee = e[8] ^ h,
            te = e[9] ^ f,
            ne = e[18] ^ h,
            re = e[19] ^ f,
            ie = e[28] ^ h,
            se = e[29] ^ f,
            ae = e[38] ^ h,
            oe = e[39] ^ f,
            ce = e[48] ^ h,
            le = e[49] ^ f,
            ue = p,
            de = _,
            he = m << 4 | g >>> 28,
            fe = g << 4 | m >>> 28,
            pe = b << 3 | y >>> 29,
            _e = y << 3 | b >>> 29,
            ge = w << 9 | v >>> 23,
            me = v << 9 | w >>> 23,
            be = E << 18 | S >>> 14,
            ye = S << 18 | E >>> 14,
            ve = k << 1 | C >>> 31,
            we = C << 1 | k >>> 31,
            Ee = M << 12 | I >>> 20,
            Se = I << 12 | M >>> 20,
            ke = R << 10 | x >>> 22,
            Ce = x << 10 | R >>> 22,
            Ie = A << 13 | L >>> 19,
            Me = L << 13 | A >>> 19,
            Re = P << 2 | T >>> 30,
            xe = T << 2 | P >>> 30,
            Le = N << 30 | j >>> 2,
            Ae = j << 30 | N >>> 2,
            Pe = O << 6 | D >>> 26,
            Te = D << 6 | O >>> 26,
            je = U << 11 | B >>> 21,
            Ne = B << 11 | U >>> 21,
            Oe = W << 15 | q >>> 17,
            De = q << 15 | W >>> 17,
            Be = F << 29 | H >>> 3,
            Ue = H << 29 | F >>> 3,
            We = z << 28 | V >>> 4,
            qe = V << 28 | z >>> 4,
            He = Z << 23 | K >>> 9,
            Fe = K << 23 | Z >>> 9,
            ze = G << 25 | $ >>> 7,
            Ve = $ << 25 | G >>> 7,
            Ke = Y << 21 | J >>> 11,
            Ze = J << 21 | Y >>> 11,
            Ge = X << 24 | Q >>> 8,
            $e = Q << 24 | X >>> 8,
            Ye = ee << 27 | te >>> 5,
            Je = te << 27 | ee >>> 5,
            Qe = ne << 20 | re >>> 12,
            Xe = re << 20 | ne >>> 12,
            et = se << 7 | ie >>> 25,
            tt = ie << 7 | se >>> 25,
            nt = ae << 8 | oe >>> 24,
            rt = oe << 8 | ae >>> 24,
            it = ce << 14 | le >>> 18,
            st = le << 14 | ce >>> 18;
        e[0] = ue ^ ~Ee & je, e[1] = de ^ ~Se & Ne, e[10] = We ^ ~Qe & pe, e[11] = qe ^ ~Xe & _e, e[20] = ve ^ ~Pe & ze, e[21] = we ^ ~Te & Ve, e[30] = Ye ^ ~he & ke, e[31] = Je ^ ~fe & Ce, e[40] = Le ^ ~He & et, e[41] = Ae ^ ~Fe & tt, e[2] = Ee ^ ~je & Ke, e[3] = Se ^ ~Ne & Ze, e[12] = Qe ^ ~pe & Ie, e[13] = Xe ^ ~_e & Me, e[22] = Pe ^ ~ze & nt, e[23] = Te ^ ~Ve & rt, e[32] = he ^ ~ke & Oe, e[33] = fe ^ ~Ce & De, e[42] = He ^ ~et & ge, e[43] = Fe ^ ~tt & me, e[4] = je ^ ~Ke & it, e[5] = Ne ^ ~Ze & st, e[14] = pe ^ ~Ie & Be, e[15] = _e ^ ~Me & Ue, e[24] = ze ^ ~nt & be, e[25] = Ve ^ ~rt & ye, e[34] = ke ^ ~Oe & Ge, e[35] = Ce ^ ~De & $e, e[44] = et ^ ~ge & Re, e[45] = tt ^ ~me & xe, e[6] = Ke ^ ~it & ue, e[7] = Ze ^ ~st & de, e[16] = Ie ^ ~Be & We, e[17] = Me ^ ~Ue & qe, e[26] = nt ^ ~be & ve, e[27] = rt ^ ~ye & we, e[36] = Oe ^ ~Ge & Ye, e[37] = De ^ ~$e & Je, e[46] = ge ^ ~Re & Le, e[47] = me ^ ~xe & Ae, e[8] = it ^ ~ue & Ee, e[9] = st ^ ~de & Se, e[18] = Be ^ ~We & Qe, e[19] = Ue ^ ~qe & Xe, e[28] = be ^ ~ve & Pe, e[29] = ye ^ ~we & Te, e[38] = Ge ^ ~Ye & he, e[39] = $e ^ ~Je & fe, e[48] = Re ^ ~Le & He, e[49] = xe ^ ~Ae & Fe, e[0] ^= Nt[2 * t], e[1] ^= Nt[2 * t + 1]
    }
};
const Ot = jt;

function Dt() {
    this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.blockSize = null, this.count = 0, this.squeezing = !1
}
Dt.prototype.initialize = function(e, t) {
    for (let n = 0; n < 50; ++n) this.state[n] = 0;
    this.blockSize = e / 8, this.count = 0, this.squeezing = !1
}, Dt.prototype.absorb = function(e) {
    for (let t = 0; t < e.length; ++t) this.state[~~(this.count / 4)] ^= e[t] << this.count % 4 * 8, this.count += 1, this.count === this.blockSize && (Ot.p1600(this.state), this.count = 0)
}, Dt.prototype.absorbLastFewBits = function(e) {
    this.state[~~(this.count / 4)] ^= e << this.count % 4 * 8, 128 & e && this.count === this.blockSize - 1 && Ot.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << (this.blockSize - 1) % 4 * 8, Ot.p1600(this.state), this.count = 0, this.squeezing = !0
}, Dt.prototype.squeeze = function(e) {
    this.squeezing || this.absorbLastFewBits(1);
    const t = Buffer.alloc(e);
    for (let n = 0; n < e; ++n) t[n] = this.state[~~(this.count / 4)] >>> this.count % 4 * 8 & 255, this.count += 1, this.count === this.blockSize && (Ot.p1600(this.state), this.count = 0);
    return t
}, Dt.prototype.copy = function(e) {
    for (let t = 0; t < 50; ++t) e.state[t] = this.state[t];
    e.blockSize = this.blockSize, e.count = this.count, e.squeezing = this.squeezing
};
const Bt = function(e) {
    const t = Pt(e),
        n = Tt(e);
    return function(e, r) {
        switch ("string" == typeof e ? e.toLowerCase() : e) {
            case "keccak224":
                return new t(1152, 448, null, 224, r);
            case "keccak256":
                return new t(1088, 512, null, 256, r);
            case "keccak384":
                return new t(832, 768, null, 384, r);
            case "keccak512":
                return new t(576, 1024, null, 512, r);
            case "sha3-224":
                return new t(1152, 448, 6, 224, r);
            case "sha3-256":
                return new t(1088, 512, 6, 256, r);
            case "sha3-384":
                return new t(832, 768, 6, 384, r);
            case "sha3-512":
                return new t(576, 1024, 6, 512, r);
            case "shake128":
                return new n(1344, 256, 31, r);
            case "shake256":
                return new n(1088, 512, 31, r);
            default:
                throw new Error("Invald algorithm: " + e)
        }
    }
}(Dt);

function Ut(e) {
    return Buffer.allocUnsafe(e).fill(0)
}

function Wt(e, t) {
    let n = e.toString(16);
    n.length % 2 != 0 && (n = "0" + n);
    const r = n.match(/.{1,2}/g).map((e => parseInt(e, 16)));
    for (; r.length < t;) r.unshift(0);
    return Buffer.from(r)
}

function qt(e, t, n) {
    const r = Ut(t);
    return e = Ht(e), n ? e.length < t ? (e.copy(r), r) : e.slice(0, t) : e.length < t ? (e.copy(r, t - e.length), r) : e.slice(-t)
}

function Ht(e) {
    if (!Buffer.isBuffer(e))
        if (Array.isArray(e)) e = Buffer.from(e);
        else if ("string" == typeof e) e = Ft(e) ? Buffer.from((t = zt(e)).length % 2 ? "0" + t : t, "hex") : Buffer.from(e);
    else if ("number" == typeof e) e = intToBuffer(e);
    else if (null == e) e = Buffer.allocUnsafe(0);
    else if ("bigint" == typeof e) e = Wt(e);
    else {
        if (!e.toArray) throw new Error("invalid type");
        e = Buffer.from(e.toArray())
    }
    var t;
    return e
}

function Ft(e) {
    return "string" == typeof e && e.match(/^0x[0-9A-Fa-f]*$/)
}

function zt(e) {
    return "string" == typeof e && e.startsWith("0x") ? e.slice(2) : e
}
var Vt = {
    zeros: Ut,
    setLength: qt,
    setLengthRight: function(e, t) {
        return qt(e, t, !0)
    },
    isHexString: Ft,
    stripHexPrefix: zt,
    toBuffer: Ht,
    bufferToHex: function(e) {
        return "0x" + (e = Ht(e)).toString("hex")
    },
    keccak: function(e, t) {
        return e = Ht(e), t || (t = 256), Bt("keccak" + t).update(e).digest()
    },
    bitLengthFromBigInt: function(e) {
        return e.toString(2).length
    },
    bufferBEFromBigInt: Wt,
    twosFromBigInt: function(e, t) {
        let n;
        if (e < 0 n) {
            n = (~e & (1 n << BigInt(t)) - 1 n) + 1 n
        } else n = e;
        return n &= (1 n << BigInt(t)) - 1 n, n
    }
};
const Kt = Vt;

function Zt(e) {
    return e.startsWith("int[") ? "int256" + e.slice(3) : "int" === e ? "int256" : e.startsWith("uint[") ? "uint256" + e.slice(4) : "uint" === e ? "uint256" : e.startsWith("fixed[") ? "fixed128x128" + e.slice(5) : "fixed" === e ? "fixed128x128" : e.startsWith("ufixed[") ? "ufixed128x128" + e.slice(6) : "ufixed" === e ? "ufixed128x128" : e
}

function Gt(e) {
    return parseInt(/^\D+(\d+)$/.exec(e)[1], 10)
}

function $t(e) {
    var t = /^\D+(\d+)x(\d+)$/.exec(e);
    return [parseInt(t[1], 10), parseInt(t[2], 10)]
}

function Yt(e) {
    var t = e.match(/(.*)\[(.*?)\]$/);
    return t ? "" === t[2] ? "dynamic" : parseInt(t[2], 10) : null
}

function Jt(e) {
    var t = typeof e;
    if ("string" === t || "number" === t) return BigInt(e);
    if ("bigint" === t) return e;
    throw new Error("Argument is not a number")
}

function Qt(e, t) {
    var n, r, i, s;
    if ("address" === e) return Qt("uint160", Jt(t));
    if ("bool" === e) return Qt("uint8", t ? 1 : 0);
    if ("string" === e) return Qt("bytes", new Buffer(t, "utf8"));
    if (function(e) {
            return e.lastIndexOf("]") === e.length - 1
        }(e)) {
        if (void 0 === t.length) throw new Error("Not an array?");
        if ("dynamic" !== (n = Yt(e)) && 0 !== n && t.length > n) throw new Error("Elements exceed array size: " + n);
        for (s in i = [], e = e.slice(0, e.lastIndexOf("[")), "string" == typeof t && (t = JSON.parse(t)), t) i.push(Qt(e, t[s]));
        if ("dynamic" === n) {
            var a = Qt("uint256", t.length);
            i.unshift(a)
        }
        return Buffer.concat(i)
    }
    if ("bytes" === e) return t = new Buffer(t), i = Buffer.concat([Qt("uint256", t.length), t]), t.length % 32 != 0 && (i = Buffer.concat([i, Kt.zeros(32 - t.length % 32)])), i;
    if (e.startsWith("bytes")) {
        if ((n = Gt(e)) < 1 || n > 32) throw new Error("Invalid bytes<N> width: " + n);
        return Kt.setLengthRight(t, 32)
    }
    if (e.startsWith("uint")) {
        if ((n = Gt(e)) % 8 || n < 8 || n > 256) throw new Error("Invalid uint<N> width: " + n);
        r = Jt(t);
        const i = Kt.bitLengthFromBigInt(r);
        if (i > n) throw new Error("Supplied uint exceeds width: " + n + " vs " + i);
        if (r < 0) throw new Error("Supplied uint is negative");
        return Kt.bufferBEFromBigInt(r, 32)
    }
    if (e.startsWith("int")) {
        if ((n = Gt(e)) % 8 || n < 8 || n > 256) throw new Error("Invalid int<N> width: " + n);
        r = Jt(t);
        const i = Kt.bitLengthFromBigInt(r);
        if (i > n) throw new Error("Supplied int exceeds width: " + n + " vs " + i);
        const s = Kt.twosFromBigInt(r, 256);
        return Kt.bufferBEFromBigInt(s, 32)
    }
    if (e.startsWith("ufixed")) {
        if (n = $t(e), (r = Jt(t)) < 0) throw new Error("Supplied ufixed is negative");
        return Qt("uint256", r * BigInt(2) ** BigInt(n[1]))
    }
    if (e.startsWith("fixed")) return n = $t(e), Qt("int256", Jt(t) * BigInt(2) ** BigInt(n[1]));
    throw new Error("Unsupported or invalid type: " + e)
}

function Xt(e) {
    return "string" === e || "bytes" === e || "dynamic" === Yt(e)
}

function en(e, t) {
    if (e.length !== t.length) throw new Error("Number of types are not matching the values");
    for (var n, r, i = [], s = 0; s < e.length; s++) {
        var a = Zt(e[s]),
            o = t[s];
        if ("bytes" === a) i.push(o);
        else if ("string" === a) i.push(new Buffer(o, "utf8"));
        else if ("bool" === a) i.push(new Buffer(o ? "01" : "00", "hex"));
        else if ("address" === a) i.push(Kt.setLength(o, 20));
        else if (a.startsWith("bytes")) {
            if ((n = Gt(a)) < 1 || n > 32) throw new Error("Invalid bytes<N> width: " + n);
            i.push(Kt.setLengthRight(o, n))
        } else if (a.startsWith("uint")) {
            if ((n = Gt(a)) % 8 || n < 8 || n > 256) throw new Error("Invalid uint<N> width: " + n);
            r = Jt(o);
            const e = Kt.bitLengthFromBigInt(r);
            if (e > n) throw new Error("Supplied uint exceeds width: " + n + " vs " + e);
            i.push(Kt.bufferBEFromBigInt(r, n / 8))
        } else {
            if (!a.startsWith("int")) throw new Error("Unsupported or invalid type: " + a); {
                if ((n = Gt(a)) % 8 || n < 8 || n > 256) throw new Error("Invalid int<N> width: " + n);
                r = Jt(o);
                const e = Kt.bitLengthFromBigInt(r);
                if (e > n) throw new Error("Supplied int exceeds width: " + n + " vs " + e);
                const t = Kt.twosFromBigInt(r, n);
                i.push(Kt.bufferBEFromBigInt(t, n / 8))
            }
        }
    }
    return Buffer.concat(i)
}
const tn = Vt,
    nn = {
        rawEncode: function(e, t) {
            var n = [],
                r = [],
                i = 32 * e.length;
            for (var s in e) {
                var a = Zt(e[s]),
                    o = Qt(a, t[s]);
                Xt(a) ? (n.push(Qt("uint256", i)), r.push(o), i += o.length) : n.push(o)
            }
            return Buffer.concat(n.concat(r))
        },
        solidityPack: en,
        soliditySHA3: function(e, t) {
            return Kt.keccak(en(e, t))
        }
    },
    rn = {
        type: "object",
        properties: {
            types: {
                type: "object",
                additionalProperties: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            name: {
                                type: "string"
                            },
                            type: {
                                type: "string"
                            }
                        },
                        required: ["name", "type"]
                    }
                }
            },
            primaryType: {
                type: "string"
            },
            domain: {
                type: "object"
            },
            message: {
                type: "object"
            }
        },
        required: ["types", "primaryType", "domain", "message"]
    },
    sn = {
        encodeData(e, t, n, r = !0) {
            const i = ["bytes32"],
                s = [this.hashType(e, n)];
            if (r) {
                const a = (e, t, i) => {
                    if (void 0 !== n[t]) return ["bytes32", null == i ? "0x0000000000000000000000000000000000000000000000000000000000000000" : tn.keccak(this.encodeData(t, i, n, r))];
                    if (void 0 === i) throw new Error(`missing value for field ${e} of type ${t}`);
                    if ("bytes" === t) return ["bytes32", tn.keccak(i)];
                    if ("string" === t) return "string" == typeof i && (i = Buffer.from(i, "utf8")), ["bytes32", tn.keccak(i)];
                    if (t.lastIndexOf("]") === t.length - 1) {
                        const n = t.slice(0, t.lastIndexOf("[")),
                            r = i.map((t => a(e, n, t)));
                        return ["bytes32", tn.keccak(nn.rawEncode(r.map((([e]) => e)), r.map((([, e]) => e))))]
                    }
                    return [t, i]
                };
                for (const r of n[e]) {
                    const [e, n] = a(r.name, r.type, t[r.name]);
                    i.push(e), s.push(n)
                }
            } else
                for (const a of n[e]) {
                    let e = t[a.name];
                    if (void 0 !== e)
                        if ("bytes" === a.type) i.push("bytes32"), e = tn.keccak(e), s.push(e);
                        else if ("string" === a.type) i.push("bytes32"), "string" == typeof e && (e = Buffer.from(e, "utf8")), e = tn.keccak(e), s.push(e);
                    else if (void 0 !== n[a.type]) i.push("bytes32"), e = tn.keccak(this.encodeData(a.type, e, n, r)), s.push(e);
                    else {
                        if (a.type.lastIndexOf("]") === a.type.length - 1) throw new Error("Arrays currently unimplemented in encodeData");
                        i.push(a.type), s.push(e)
                    }
                }
            return nn.rawEncode(i, s)
        },
        encodeType(e, t) {
            let n = "",
                r = this.findTypeDependencies(e, t).filter((t => t !== e));
            r = [e].concat(r.sort());
            for (const i of r) {
                if (!t[i]) throw new Error("No type definition specified: " + i);
                n += i + "(" + t[i].map((({
                    name: e,
                    type: t
                }) => t + " " + e)).join(",") + ")"
            }
            return n
        },
        findTypeDependencies(e, t, n = []) {
            if (e = e.match(/^\w*/)[0], n.includes(e) || void 0 === t[e]) return n;
            n.push(e);
            for (const r of t[e])
                for (const e of this.findTypeDependencies(r.type, t, n)) !n.includes(e) && n.push(e);
            return n
        },
        hashStruct(e, t, n, r = !0) {
            return tn.keccak(this.encodeData(e, t, n, r))
        },
        hashType(e, t) {
            return tn.keccak(this.encodeType(e, t))
        },
        sanitizeData(e) {
            const t = {};
            for (const n in rn.properties) e[n] && (t[n] = e[n]);
            return t.types && (t.types = Object.assign({
                EIP712Domain: []
            }, t.types)), t
        },
        hash(e, t = !0) {
            const n = this.sanitizeData(e),
                r = [Buffer.from("1901", "hex")];
            return r.push(this.hashStruct("EIP712Domain", n.domain, n.types, t)), "EIP712Domain" !== n.primaryType && r.push(this.hashStruct(n.primaryType, n.message, n.types, t)), tn.keccak(Buffer.concat(r))
        }
    };
var an = {
    TYPED_MESSAGE_SCHEMA: rn,
    TypedDataUtils: sn,
    hashForSignTypedDataLegacy: function(e) {
        return function(e) {
            const t = new Error("Expect argument to be non-empty array");
            if ("object" != typeof e || !e.length) throw t;
            const n = e.map((function(e) {
                    return "bytes" === e.type ? tn.toBuffer(e.value) : e.value
                })),
                r = e.map((function(e) {
                    return e.type
                })),
                i = e.map((function(e) {
                    if (!e.name) throw t;
                    return e.type + " " + e.name
                }));
            return nn.soliditySHA3(["bytes32", "bytes32"], [nn.soliditySHA3(new Array(e.length).fill("string"), i), nn.soliditySHA3(r, n)])
        }(e.data)
    },
    hashForSignTypedData_v3: function(e) {
        return sn.hash(e.data, !1)
    },
    hashForSignTypedData_v4: function(e) {
        return sn.hash(e.data)
    }
};
var on = {};
Object.defineProperty(on, "__esModule", {
    value: !0
}), on.APP_VERSION_KEY = on.LOCAL_STORAGE_ADDRESSES_KEY = on.WALLET_USER_NAME_KEY = void 0, on.WALLET_USER_NAME_KEY = "walletUsername", on.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses", on.APP_VERSION_KEY = "AppVersion";
var cn = {};
Object.defineProperty(cn, "__esModule", {
    value: !0
}), cn.RelayEventManager = void 0;
const ln = P;
cn.RelayEventManager = class {
    constructor() {
        this._nextRequestId = 0, this.callbacks = new Map
    }
    makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const e = this._nextRequestId,
            t = (0, ln.prepend0x)(e.toString(16));
        return this.callbacks.get(t) && this.callbacks.delete(t), e
    }
};
var un = {},
    dn = {},
    hn = {};
Object.defineProperty(hn, "__esModule", {
    value: !0
}), hn.WalletLinkCipher = void 0;
const fn = P;
hn.WalletLinkCipher = class {
    constructor(e) {
        this.secret = e
    }
    async encrypt(e) {
        const t = this.secret;
        if (64 !== t.length) throw Error("secret must be 256 bits");
        const n = crypto.getRandomValues(new Uint8Array(12)),
            r = await crypto.subtle.importKey("raw", (0, fn.hexStringToUint8Array)(t), {
                name: "aes-gcm"
            }, !1, ["encrypt", "decrypt"]),
            i = new TextEncoder,
            s = await window.crypto.subtle.encrypt({
                name: "AES-GCM",
                iv: n
            }, r, i.encode(e)),
            a = s.slice(s.byteLength - 16),
            o = s.slice(0, s.byteLength - 16),
            c = new Uint8Array(a),
            l = new Uint8Array(o),
            u = new Uint8Array([...n, ...c, ...l]);
        return (0, fn.uint8ArrayToHex)(u)
    }
    async decrypt(e) {
        const t = this.secret;
        if (64 !== t.length) throw Error("secret must be 256 bits");
        return new Promise(((n, r) => {
            !async function() {
                const i = await crypto.subtle.importKey("raw", (0, fn.hexStringToUint8Array)(t), {
                        name: "aes-gcm"
                    }, !1, ["encrypt", "decrypt"]),
                    s = (0, fn.hexStringToUint8Array)(e),
                    a = s.slice(0, 12),
                    o = s.slice(12, 28),
                    c = s.slice(28),
                    l = new Uint8Array([...c, ...o]),
                    u = {
                        name: "AES-GCM",
                        iv: new Uint8Array(a)
                    };
                try {
                    const e = await window.crypto.subtle.decrypt(u, i, l),
                        t = new TextDecoder;
                    n(t.decode(e))
                } catch (d) {
                    r(d)
                }
            }()
        }))
    }
};
var pn = {};
Object.defineProperty(pn, "__esModule", {
    value: !0
}), pn.WalletLinkHTTP = void 0;
pn.WalletLinkHTTP = class {
    constructor(e, t, n) {
        this.linkAPIUrl = e, this.sessionId = t;
        const r = `${t}:${n}`;
        this.auth = `Basic ${btoa(r)}`
    }
    async markUnseenEventsAsSeen(e) {
        return Promise.all(e.map((e => fetch(`${this.linkAPIUrl}/events/${e.eventId}/seen`, {
            method: "POST",
            headers: {
                Authorization: this.auth
            }
        })))).catch((e => console.error("Unabled to mark event as failed:", e)))
    }
    async fetchUnseenEvents() {
        var e;
        const t = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
            headers: {
                Authorization: this.auth
            }
        });
        if (t.ok) {
            const {
                events: n,
                error: r
            } = await t.json();
            if (r) throw new Error(`Check unseen events failed: ${r}`);
            const i = null !== (e = null == n ? void 0 : n.filter((e => "Web3Response" === e.event)).map((e => ({
                type: "Event",
                sessionId: this.sessionId,
                eventId: e.id,
                event: e.event,
                data: e.data
            })))) && void 0 !== e ? e : [];
            return this.markUnseenEventsAsSeen(i), i
        }
        throw new Error(`Check unseen events failed: ${t.status}`)
    }
};
var _n, gn, mn = {};
Object.defineProperty(mn, "__esModule", {
    value: !0
}), mn.WalletLinkWebSocket = mn.ConnectionState = void 0, (gn = _n || (mn.ConnectionState = _n = {}))[gn.DISCONNECTED = 0] = "DISCONNECTED", gn[gn.CONNECTING = 1] = "CONNECTING", gn[gn.CONNECTED = 2] = "CONNECTED";
mn.WalletLinkWebSocket = class {
    setConnectionStateListener(e) {
        this.connectionStateListener = e
    }
    setIncomingDataListener(e) {
        this.incomingDataListener = e
    }
    constructor(e, t = WebSocket) {
        this.WebSocketClass = t, this.webSocket = null, this.pendingData = [], this.url = e.replace(/^http/, "ws")
    }
    async connect() {
        if (this.webSocket) throw new Error("webSocket object is not null");
        return new Promise(((e, t) => {
            var n;
            let r;
            try {
                this.webSocket = r = new this.WebSocketClass(this.url)
            } catch (i) {
                return void t(i)
            }
            null === (n = this.connectionStateListener) || void 0 === n || n.call(this, _n.CONNECTING), r.onclose = e => {
                var n;
                this.clearWebSocket(), t(new Error(`websocket error ${e.code}: ${e.reason}`)), null === (n = this.connectionStateListener) || void 0 === n || n.call(this, _n.DISCONNECTED)
            }, r.onopen = t => {
                var n;
                if (e(), null === (n = this.connectionStateListener) || void 0 === n || n.call(this, _n.CONNECTED), this.pendingData.length > 0) {
                    [...this.pendingData].forEach((e => this.sendData(e))), this.pendingData = []
                }
            }, r.onmessage = e => {
                var t, n;
                if ("h" === e.data) null === (t = this.incomingDataListener) || void 0 === t || t.call(this, {
                    type: "Heartbeat"
                });
                else try {
                    const t = JSON.parse(e.data);
                    null === (n = this.incomingDataListener) || void 0 === n || n.call(this, t)
                } catch (r) {}
            }
        }))
    }
    disconnect() {
        var e;
        const {
            webSocket: t
        } = this;
        if (t) {
            this.clearWebSocket(), null === (e = this.connectionStateListener) || void 0 === e || e.call(this, _n.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
            try {
                t.close()
            } catch (n) {}
        }
    }
    sendData(e) {
        const {
            webSocket: t
        } = this;
        if (!t) return this.pendingData.push(e), void this.connect();
        t.send(e)
    }
    clearWebSocket() {
        const {
            webSocket: e
        } = this;
        e && (this.webSocket = null, e.onclose = null, e.onerror = null, e.onmessage = null, e.onopen = null)
    }
}, Object.defineProperty(dn, "__esModule", {
    value: !0
}), dn.WalletLinkConnection = void 0;
const bn = on,
    yn = hn,
    vn = pn,
    wn = mn,
    En = L;
dn.WalletLinkConnection = class {
    constructor({
        session: e,
        linkAPIUrl: t,
        listener: n,
        WebSocketClass: r = WebSocket
    }) {
        this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = (0, En.IntNumber)(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = new Map, this.handleSessionMetadataUpdated = e => {
            if (!e) return;
            new Map([
                ["__destroyed", this.handleDestroyed],
                ["EthereumAddress", this.handleAccountUpdated],
                ["WalletUsername", this.handleWalletUsernameUpdated],
                ["AppVersion", this.handleAppVersionUpdated],
                ["ChainId", t => e.JsonRpcUrl && this.handleChainUpdated(t, e.JsonRpcUrl)]
            ]).forEach(((t, n) => {
                const r = e[n];
                void 0 !== r && t(r)
            }))
        }, this.handleDestroyed = e => {
            var t;
            "1" === e && (null === (t = this.listener) || void 0 === t || t.resetAndReload())
        }, this.handleAccountUpdated = async e => {
            var t; {
                const n = await this.cipher.decrypt(e);
                null === (t = this.listener) || void 0 === t || t.accountUpdated(n)
            }
        }, this.handleMetadataUpdated = async (e, t) => {
            var n; {
                const r = await this.cipher.decrypt(t);
                null === (n = this.listener) || void 0 === n || n.metadataUpdated(e, r)
            }
        }, this.handleWalletUsernameUpdated = async e => {
            this.handleMetadataUpdated(bn.WALLET_USER_NAME_KEY, e)
        }, this.handleAppVersionUpdated = async e => {
            this.handleMetadataUpdated(bn.APP_VERSION_KEY, e)
        }, this.handleChainUpdated = async (e, t) => {
            var n; {
                const r = await this.cipher.decrypt(e),
                    i = await this.cipher.decrypt(t);
                null === (n = this.listener) || void 0 === n || n.chainUpdated(r, i)
            }
        }, this.session = e, this.cipher = new yn.WalletLinkCipher(e.secret), this.listener = n;
        const i = new wn.WalletLinkWebSocket(`${t}/rpc`, r);
        i.setConnectionStateListener((async e => {
            let t = !1;
            switch (e) {
                case wn.ConnectionState.DISCONNECTED:
                    if (!this.destroyed) {
                        const e = async () => {
                            await new Promise((e => setTimeout(e, 5e3))), this.destroyed || i.connect().catch((() => {
                                e()
                            }))
                        };
                        e()
                    }
                    break;
                case wn.ConnectionState.CONNECTED:
                    try {
                        await this.authenticate(), this.sendIsLinked(), this.sendGetSessionConfig(), t = !0
                    } catch (n) {}
                    this.updateLastHeartbeat(), setInterval((() => {
                        this.heartbeat()
                    }), 1e4), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
                case wn.ConnectionState.CONNECTING:
            }
            this.connected !== t && (this.connected = t)
        })), i.setIncomingDataListener((e => {
            var t;
            switch (e.type) {
                case "Heartbeat":
                    return void this.updateLastHeartbeat();
                case "IsLinkedOK":
                case "Linked":
                    {
                        const t = "IsLinkedOK" === e.type ? e.linked : void 0;this.linked = t || e.onlineGuests > 0;
                        break
                    }
                case "GetSessionConfigOK":
                case "SessionConfigUpdated":
                    this.handleSessionMetadataUpdated(e.metadata);
                    break;
                case "Event":
                    this.handleIncomingEvent(e)
            }
            void 0 !== e.id && (null === (t = this.requestResolutions.get(e.id)) || void 0 === t || t(e))
        })), this.ws = i, this.http = new vn.WalletLinkHTTP(t, e.id, e.key)
    }
    connect() {
        if (this.destroyed) throw new Error("instance is destroyed");
        this.ws.connect()
    }
    destroy() {
        this.destroyed = !0, this.ws.disconnect(), this.listener = void 0
    }
    get isDestroyed() {
        return this.destroyed
    }
    get connected() {
        return this._connected
    }
    set connected(e) {
        var t;
        this._connected = e, e && (null === (t = this.onceConnected) || void 0 === t || t.call(this))
    }
    setOnceConnected(e) {
        return new Promise((t => {
            this.connected ? e().then(t) : this.onceConnected = () => {
                e().then(t), this.onceConnected = void 0
            }
        }))
    }
    get linked() {
        return this._linked
    }
    set linked(e) {
        var t, n;
        this._linked = e, e && (null === (t = this.onceLinked) || void 0 === t || t.call(this)), null === (n = this.listener) || void 0 === n || n.linkedUpdated(e)
    }
    setOnceLinked(e) {
        return new Promise((t => {
            this.linked ? e().then(t) : this.onceLinked = () => {
                e().then(t), this.onceLinked = void 0
            }
        }))
    }
    async handleIncomingEvent(e) {
        var t;
        if ("Event" === e.type && "Web3Response" === e.event) {
            const n = await this.cipher.decrypt(e.data),
                r = JSON.parse(n);
            if ("WEB3_RESPONSE" !== r.type) return;
            null === (t = this.listener) || void 0 === t || t.handleWeb3ResponseMessage(r)
        }
    }
    async checkUnseenEvents() {
        if (this.connected) {
            await new Promise((e => setTimeout(e, 250)));
            try {
                await this.fetchUnseenEventsAPI()
            } catch (e) {
                console.error("Unable to check for unseen events", e)
            }
        } else this.shouldFetchUnseenEventsOnConnect = !0
    }
    async fetchUnseenEventsAPI() {
        this.shouldFetchUnseenEventsOnConnect = !1;
        (await this.http.fetchUnseenEvents()).forEach((e => this.handleIncomingEvent(e)))
    }
    async setSessionMetadata(e, t) {
        const n = {
            type: "SetSessionConfig",
            id: (0, En.IntNumber)(this.nextReqId++),
            sessionId: this.session.id,
            metadata: {
                [e]: t
            }
        };
        return this.setOnceConnected((async () => {
            const e = await this.makeRequest(n);
            if ("Fail" === e.type) throw new Error(e.error || "failed to set session metadata")
        }))
    }
    async publishEvent(e, t, n = !1) {
        const r = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, t), {
                origin: location.origin,
                relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk"
            }))),
            i = {
                type: "PublishEvent",
                id: (0, En.IntNumber)(this.nextReqId++),
                sessionId: this.session.id,
                event: e,
                data: r,
                callWebhook: n
            };
        return this.setOnceLinked((async () => {
            const e = await this.makeRequest(i);
            if ("Fail" === e.type) throw new Error(e.error || "failed to publish event");
            return e.eventId
        }))
    }
    sendData(e) {
        this.ws.sendData(JSON.stringify(e))
    }
    updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now()
    }
    heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > 2e4) this.ws.disconnect();
        else try {
            this.ws.sendData("h")
        } catch (e) {}
    }
    async makeRequest(e, t = 6e4) {
        const n = e.id;
        let r;
        return this.sendData(e), Promise.race([new Promise(((e, i) => {
            r = window.setTimeout((() => {
                i(new Error(`request ${n} timed out`))
            }), t)
        })), new Promise((e => {
            this.requestResolutions.set(n, (t => {
                clearTimeout(r), e(t), this.requestResolutions.delete(n)
            }))
        }))])
    }
    async authenticate() {
        const e = {
                type: "HostSession",
                id: (0, En.IntNumber)(this.nextReqId++),
                sessionId: this.session.id,
                sessionKey: this.session.key
            },
            t = await this.makeRequest(e);
        if ("Fail" === t.type) throw new Error(t.error || "failed to authenticate")
    }
    sendIsLinked() {
        const e = {
            type: "IsLinked",
            id: (0, En.IntNumber)(this.nextReqId++),
            sessionId: this.session.id
        };
        this.sendData(e)
    }
    sendGetSessionConfig() {
        const e = {
            type: "GetSessionConfig",
            id: (0, En.IntNumber)(this.nextReqId++),
            sessionId: this.session.id
        };
        this.sendData(e)
    }
};
var Sn = {},
    kn = {
        exports: {}
    },
    Cn = Ze.Buffer;

function In(e, t) {
    this._block = Cn.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0
}
In.prototype.update = function(e, t) {
    "string" == typeof e && (t = t || "utf8", e = Cn.from(e, t));
    for (var n = this._block, r = this._blockSize, i = e.length, s = this._len, a = 0; a < i;) {
        for (var o = s % r, c = Math.min(i - a, r - o), l = 0; l < c; l++) n[o + l] = e[a + l];
        a += c, (s += c) % r == 0 && this._update(n)
    }
    return this._len += i, this
}, In.prototype.digest = function(e) {
    var t = this._len % this._blockSize;
    this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var n = 8 * this._len;
    if (n <= 4294967295) this._block.writeUInt32BE(n, this._blockSize - 4);
    else {
        var r = (4294967295 & n) >>> 0,
            i = (n - r) / 4294967296;
        this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(r, this._blockSize - 4)
    }
    this._update(this._block);
    var s = this._hash();
    return e ? s.toString(e) : s
}, In.prototype._update = function() {
    throw new Error("_update must be implemented by subclass")
};
var Mn = In,
    Rn = Ue,
    xn = Mn,
    Ln = Ze.Buffer,
    An = [1518500249, 1859775393, -1894007588, -899497514],
    Pn = new Array(80);

function Tn() {
    this.init(), this._w = Pn, xn.call(this, 64, 56)
}

function jn(e) {
    return e << 30 | e >>> 2
}

function Nn(e, t, n, r) {
    return 0 === e ? t & n | ~t & r : 2 === e ? t & n | t & r | n & r : t ^ n ^ r
}
Rn(Tn, xn), Tn.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
}, Tn.prototype._update = function(e) {
    for (var t, n = this._w, r = 0 | this._a, i = 0 | this._b, s = 0 | this._c, a = 0 | this._d, o = 0 | this._e, c = 0; c < 16; ++c) n[c] = e.readInt32BE(4 * c);
    for (; c < 80; ++c) n[c] = n[c - 3] ^ n[c - 8] ^ n[c - 14] ^ n[c - 16];
    for (var l = 0; l < 80; ++l) {
        var u = ~~(l / 20),
            d = 0 | ((t = r) << 5 | t >>> 27) + Nn(u, i, s, a) + o + n[l] + An[u];
        o = a, a = s, s = jn(i), i = r, r = d
    }
    this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = s + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0
}, Tn.prototype._hash = function() {
    var e = Ln.allocUnsafe(20);
    return e.writeInt32BE(0 | this._a, 0), e.writeInt32BE(0 | this._b, 4), e.writeInt32BE(0 | this._c, 8), e.writeInt32BE(0 | this._d, 12), e.writeInt32BE(0 | this._e, 16), e
};
var On = Tn,
    Dn = Ue,
    Bn = Mn,
    Un = Ze.Buffer,
    Wn = [1518500249, 1859775393, -1894007588, -899497514],
    qn = new Array(80);

function Hn() {
    this.init(), this._w = qn, Bn.call(this, 64, 56)
}

function Fn(e) {
    return e << 5 | e >>> 27
}

function zn(e) {
    return e << 30 | e >>> 2
}

function Vn(e, t, n, r) {
    return 0 === e ? t & n | ~t & r : 2 === e ? t & n | t & r | n & r : t ^ n ^ r
}
Dn(Hn, Bn), Hn.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
}, Hn.prototype._update = function(e) {
    for (var t, n = this._w, r = 0 | this._a, i = 0 | this._b, s = 0 | this._c, a = 0 | this._d, o = 0 | this._e, c = 0; c < 16; ++c) n[c] = e.readInt32BE(4 * c);
    for (; c < 80; ++c) n[c] = (t = n[c - 3] ^ n[c - 8] ^ n[c - 14] ^ n[c - 16]) << 1 | t >>> 31;
    for (var l = 0; l < 80; ++l) {
        var u = ~~(l / 20),
            d = Fn(r) + Vn(u, i, s, a) + o + n[l] + Wn[u] | 0;
        o = a, a = s, s = zn(i), i = r, r = d
    }
    this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = s + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0
}, Hn.prototype._hash = function() {
    var e = Un.allocUnsafe(20);
    return e.writeInt32BE(0 | this._a, 0), e.writeInt32BE(0 | this._b, 4), e.writeInt32BE(0 | this._c, 8), e.writeInt32BE(0 | this._d, 12), e.writeInt32BE(0 | this._e, 16), e
};
var Kn = Hn,
    Zn = Ue,
    Gn = Mn,
    $n = Ze.Buffer,
    Yn = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
    Jn = new Array(64);

function Qn() {
    this.init(), this._w = Jn, Gn.call(this, 64, 56)
}

function Xn(e, t, n) {
    return n ^ e & (t ^ n)
}

function er(e, t, n) {
    return e & t | n & (e | t)
}

function tr(e) {
    return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10)
}

function nr(e) {
    return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)
}

function rr(e) {
    return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3
}
Zn(Qn, Gn), Qn.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this
}, Qn.prototype._update = function(e) {
    for (var t, n = this._w, r = 0 | this._a, i = 0 | this._b, s = 0 | this._c, a = 0 | this._d, o = 0 | this._e, c = 0 | this._f, l = 0 | this._g, u = 0 | this._h, d = 0; d < 16; ++d) n[d] = e.readInt32BE(4 * d);
    for (; d < 64; ++d) n[d] = 0 | (((t = n[d - 2]) >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10) + n[d - 7] + rr(n[d - 15]) + n[d - 16];
    for (var h = 0; h < 64; ++h) {
        var f = u + nr(o) + Xn(o, c, l) + Yn[h] + n[h] | 0,
            p = tr(r) + er(r, i, s) | 0;
        u = l, l = c, c = o, o = a + f | 0, a = s, s = i, i = r, r = f + p | 0
    }
    this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = s + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0, this._f = c + this._f | 0, this._g = l + this._g | 0, this._h = u + this._h | 0
}, Qn.prototype._hash = function() {
    var e = $n.allocUnsafe(32);
    return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e
};
var ir = Qn,
    sr = Ue,
    ar = ir,
    or = Mn,
    cr = Ze.Buffer,
    lr = new Array(64);

function ur() {
    this.init(), this._w = lr, or.call(this, 64, 56)
}
sr(ur, ar), ur.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this
}, ur.prototype._hash = function() {
    var e = cr.allocUnsafe(28);
    return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e
};
var dr = ur,
    hr = Ue,
    fr = Mn,
    pr = Ze.Buffer,
    _r = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591],
    gr = new Array(160);

function mr() {
    this.init(), this._w = gr, fr.call(this, 128, 112)
}

function br(e, t, n) {
    return n ^ e & (t ^ n)
}

function yr(e, t, n) {
    return e & t | n & (e | t)
}

function vr(e, t) {
    return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25)
}

function wr(e, t) {
    return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23)
}

function Er(e, t) {
    return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7
}

function Sr(e, t) {
    return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25)
}

function kr(e, t) {
    return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6
}

function Cr(e, t) {
    return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26)
}

function Ir(e, t) {
    return e >>> 0 < t >>> 0 ? 1 : 0
}
hr(mr, fr), mr.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this
}, mr.prototype._update = function(e) {
    for (var t = this._w, n = 0 | this._ah, r = 0 | this._bh, i = 0 | this._ch, s = 0 | this._dh, a = 0 | this._eh, o = 0 | this._fh, c = 0 | this._gh, l = 0 | this._hh, u = 0 | this._al, d = 0 | this._bl, h = 0 | this._cl, f = 0 | this._dl, p = 0 | this._el, _ = 0 | this._fl, g = 0 | this._gl, m = 0 | this._hl, b = 0; b < 32; b += 2) t[b] = e.readInt32BE(4 * b), t[b + 1] = e.readInt32BE(4 * b + 4);
    for (; b < 160; b += 2) {
        var y = t[b - 30],
            v = t[b - 30 + 1],
            w = Er(y, v),
            E = Sr(v, y),
            S = kr(y = t[b - 4], v = t[b - 4 + 1]),
            k = Cr(v, y),
            C = t[b - 14],
            I = t[b - 14 + 1],
            M = t[b - 32],
            R = t[b - 32 + 1],
            x = E + I | 0,
            L = w + C + Ir(x, E) | 0;
        L = (L = L + S + Ir(x = x + k | 0, k) | 0) + M + Ir(x = x + R | 0, R) | 0, t[b] = L, t[b + 1] = x
    }
    for (var A = 0; A < 160; A += 2) {
        L = t[A], x = t[A + 1];
        var P = yr(n, r, i),
            T = yr(u, d, h),
            j = vr(n, u),
            N = vr(u, n),
            O = wr(a, p),
            D = wr(p, a),
            B = _r[A],
            U = _r[A + 1],
            W = br(a, o, c),
            q = br(p, _, g),
            H = m + D | 0,
            F = l + O + Ir(H, m) | 0;
        F = (F = (F = F + W + Ir(H = H + q | 0, q) | 0) + B + Ir(H = H + U | 0, U) | 0) + L + Ir(H = H + x | 0, x) | 0;
        var z = N + T | 0,
            V = j + P + Ir(z, N) | 0;
        l = c, m = g, c = o, g = _, o = a, _ = p, a = s + F + Ir(p = f + H | 0, f) | 0, s = i, f = h, i = r, h = d, r = n, d = u, n = F + V + Ir(u = H + z | 0, H) | 0
    }
    this._al = this._al + u | 0, this._bl = this._bl + d | 0, this._cl = this._cl + h | 0, this._dl = this._dl + f | 0, this._el = this._el + p | 0, this._fl = this._fl + _ | 0, this._gl = this._gl + g | 0, this._hl = this._hl + m | 0, this._ah = this._ah + n + Ir(this._al, u) | 0, this._bh = this._bh + r + Ir(this._bl, d) | 0, this._ch = this._ch + i + Ir(this._cl, h) | 0, this._dh = this._dh + s + Ir(this._dl, f) | 0, this._eh = this._eh + a + Ir(this._el, p) | 0, this._fh = this._fh + o + Ir(this._fl, _) | 0, this._gh = this._gh + c + Ir(this._gl, g) | 0, this._hh = this._hh + l + Ir(this._hl, m) | 0
}, mr.prototype._hash = function() {
    var e = pr.allocUnsafe(64);

    function t(t, n, r) {
        e.writeInt32BE(t, r), e.writeInt32BE(n, r + 4)
    }
    return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e
};
var Mr = mr,
    Rr = Ue,
    xr = Mr,
    Lr = Mn,
    Ar = Ze.Buffer,
    Pr = new Array(160);

function Tr() {
    this.init(), this._w = Pr, Lr.call(this, 128, 112)
}
Rr(Tr, xr), Tr.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this
}, Tr.prototype._hash = function() {
    var e = Ar.allocUnsafe(48);

    function t(t, n, r) {
        e.writeInt32BE(t, r), e.writeInt32BE(n, r + 4)
    }
    return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e
};
var jr = Tr,
    Nr = kn.exports = function(e) {
        e = e.toLowerCase();
        var t = Nr[e];
        if (!t) throw new Error(e + " is not supported (we accept pull requests)");
        return new t
    };
Nr.sha = On, Nr.sha1 = Kn, Nr.sha224 = dr, Nr.sha256 = ir, Nr.sha384 = jr, Nr.sha512 = Mr;
var Or = kn.exports;
Object.defineProperty(Sn, "__esModule", {
    value: !0
}), Sn.WalletLinkSession = void 0;
const Dr = Or,
    Br = P,
    Ur = "session:id",
    Wr = "session:secret",
    qr = "session:linked";
class Hr {
    constructor(e, t, n, r) {
        this._storage = e, this._id = t || (0, Br.randomBytesHex)(16), this._secret = n || (0, Br.randomBytesHex)(32), this._key = (new Dr.sha256).update(`${this._id}, ${this._secret} WalletLink`).digest("hex"), this._linked = !!r
    }
    static load(e) {
        const t = e.getItem(Ur),
            n = e.getItem(qr),
            r = e.getItem(Wr);
        return t && r ? new Hr(e, t, r, "1" === n) : null
    }
    get id() {
        return this._id
    }
    get secret() {
        return this._secret
    }
    get key() {
        return this._key
    }
    get linked() {
        return this._linked
    }
    set linked(e) {
        this._linked = e, this.persistLinked()
    }
    save() {
        return this._storage.setItem(Ur, this._id), this._storage.setItem(Wr, this._secret), this.persistLinked(), this
    }
    persistLinked() {
        this._storage.setItem(qr, this._linked ? "1" : "0")
    }
}
Sn.WalletLinkSession = Hr;
var Fr = {};
Object.defineProperty(Fr, "__esModule", {
    value: !0
}), Fr.isDarkMode = Fr.isMobileWeb = Fr.getLocation = Fr.createQrUrl = void 0, Fr.createQrUrl = function(e, t, n, r, i, s) {
    const a = r ? "parent-id" : "id";
    return `${n}/#/link?${new URLSearchParams({[a]:e,secret:t,server:n,v:i,chainId:s.toString()}).toString()}`
}, Fr.getLocation = function() {
    try {
        return function() {
            try {
                return null !== window.frameElement
            } catch (e) {
                return !1
            }
        }() && window.top ? window.top.location : window.location
    } catch (e) {
        return window.location
    }
}, Fr.isMobileWeb = function() {
    var e;
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(null === (e = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === e ? void 0 : e.userAgent)
}, Fr.isDarkMode = function() {
    var e, t;
    return null !== (t = null === (e = null === window || void 0 === window ? void 0 : window.matchMedia) || void 0 === e ? void 0 : e.call(window, "(prefers-color-scheme: dark)").matches) && void 0 !== t && t
};
var zr = {},
    Vr = {},
    Kr = {};
Object.defineProperty(Kr, "__esModule", {
    value: !0
}), Kr.default = (() => '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}')();
var Zr = t && t.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
};
Object.defineProperty(Vr, "__esModule", {
    value: !0
}), Vr.injectCssReset = void 0;
const Gr = Zr(Kr);
Vr.injectCssReset = function() {
    const e = document.createElement("style");
    e.type = "text/css", e.appendChild(document.createTextNode(Gr.default)), document.documentElement.appendChild(e)
};
var $r = {};

function Yr(e) {
    var t, n, r = "";
    if ("string" == typeof e || "number" == typeof e) r += e;
    else if ("object" == typeof e)
        if (Array.isArray(e))
            for (t = 0; t < e.length; t++) e[t] && (n = Yr(e[t])) && (r && (r += " "), r += n);
        else
            for (t in e) e[t] && (r && (r += " "), r += t);
    return r
}

function Jr() {
    for (var e, t, n = 0, r = ""; n < arguments.length;)(e = arguments[n++]) && (t = Yr(e)) && (r && (r += " "), r += t);
    return r
}
const Qr = n(Object.freeze(Object.defineProperty({
    __proto__: null,
    clsx: Jr,
    default: Jr
}, Symbol.toStringTag, {
    value: "Module"
})));
var Xr, ei, ti, ni, ri, ii, si, ai, oi, ci, li, ui, di = {},
    hi = [],
    fi = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
    pi = Array.isArray;

function _i(e, t) {
    for (var n in t) e[n] = t[n];
    return e
}

function gi(e) {
    var t = e.parentNode;
    t && t.removeChild(e)
}

function mi(e, t, n) {
    var r, i, s, a = {};
    for (s in t) "key" == s ? r = t[s] : "ref" == s ? i = t[s] : a[s] = t[s];
    if (arguments.length > 2 && (a.children = arguments.length > 3 ? Xr.call(arguments, 2) : n), "function" == typeof e && null != e.defaultProps)
        for (s in e.defaultProps) void 0 === a[s] && (a[s] = e.defaultProps[s]);
    return bi(e, a, r, i, null)
}

function bi(e, t, n, r, i) {
    var s = {
        type: e,
        props: t,
        key: n,
        ref: r,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        constructor: void 0,
        __v: null == i ? ++ti : i,
        __i: -1,
        __u: 0
    };
    return null == i && null != ei.vnode && ei.vnode(s), s
}

function yi(e) {
    return e.children
}

function vi(e, t) {
    this.props = e, this.context = t
}

function wi(e, t) {
    if (null == t) return e.__ ? wi(e.__, e.__i + 1) : null;
    for (var n; t < e.__k.length; t++)
        if (null != (n = e.__k[t]) && null != n.__e) return n.__e;
    return "function" == typeof e.type ? wi(e) : null
}

function Ei(e) {
    var t, n;
    if (null != (e = e.__) && null != e.__c) {
        for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)
            if (null != (n = e.__k[t]) && null != n.__e) {
                e.__e = e.__c.base = n.__e;
                break
            }
        return Ei(e)
    }
}

function Si(e) {
    (!e.__d && (e.__d = !0) && ri.push(e) && !ki.__r++ || ii !== ei.debounceRendering) && ((ii = ei.debounceRendering) || si)(ki)
}

function ki() {
    var e, t, n, r, i, s, a, o;
    for (ri.sort(ai); e = ri.shift();) e.__d && (t = ri.length, r = void 0, s = (i = (n = e).__v).__e, a = [], o = [], n.__P && ((r = _i({}, i)).__v = i.__v + 1, ei.vnode && ei.vnode(r), Ai(n.__P, r, i, n.__n, n.__P.namespaceURI, 32 & i.__u ? [s] : null, a, null == s ? wi(i) : s, !!(32 & i.__u), o), r.__v = i.__v, r.__.__k[r.__i] = r, Pi(a, r, o), r.__e != s && Ei(r)), ri.length > t && ri.sort(ai));
    ki.__r = 0
}

function Ci(e, t, n, r, i, s, a, o, c, l, u) {
    var d, h, f, p, _, g = r && r.__k || hi,
        m = t.length;
    for (n.__d = c, function(e, t, n) {
            var r, i, s, a, o, c = t.length,
                l = n.length,
                u = l,
                d = 0;
            for (e.__k = [], r = 0; r < c; r++) a = r + d, null != (i = e.__k[r] = null == (i = t[r]) || "boolean" == typeof i || "function" == typeof i ? null : "string" == typeof i || "number" == typeof i || "bigint" == typeof i || i.constructor == String ? bi(null, i, null, null, null) : pi(i) ? bi(yi, {
                children: i
            }, null, null, null) : void 0 === i.constructor && i.__b > 0 ? bi(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) ? (i.__ = e, i.__b = e.__b + 1, o = Mi(i, n, a, u), i.__i = o, s = null, -1 !== o && (u--, (s = n[o]) && (s.__u |= 131072)), null == s || null === s.__v ? (-1 == o && d--, "function" != typeof i.type && (i.__u |= 65536)) : o !== a && (o === a + 1 ? d++ : o > a ? u > c - a ? d += o - a : d-- : o < a ? o == a - 1 && (d = o - a) : d = 0, o !== r + d && (i.__u |= 65536))) : (s = n[a]) && null == s.key && s.__e && !(131072 & s.__u) && (s.__e == e.__d && (e.__d = wi(s)), ji(s, s, !1), n[a] = null, u--);
            if (u)
                for (r = 0; r < l; r++) null != (s = n[r]) && !(131072 & s.__u) && (s.__e == e.__d && (e.__d = wi(s)), ji(s, s))
        }(n, t, g), c = n.__d, d = 0; d < m; d++) null != (f = n.__k[d]) && "boolean" != typeof f && "function" != typeof f && (h = -1 === f.__i ? di : g[f.__i] || di, f.__i = d, Ai(e, f, h, i, s, a, o, c, l, u), p = f.__e, f.ref && h.ref != f.ref && (h.ref && Ti(h.ref, null, f), u.push(f.ref, f.__c || p, f)), null == _ && null != p && (_ = p), 65536 & f.__u || h.__k === f.__k ? (c && !c.isConnected && (c = wi(h)), c = Ii(f, c, e)) : "function" == typeof f.type && void 0 !== f.__d ? c = f.__d : p && (c = p.nextSibling), f.__d = void 0, f.__u &= -196609);
    n.__d = c, n.__e = _
}

function Ii(e, t, n) {
    var r, i;
    if ("function" == typeof e.type) {
        for (r = e.__k, i = 0; r && i < r.length; i++) r[i] && (r[i].__ = e, t = Ii(r[i], t, n));
        return t
    }
    e.__e != t && (n.insertBefore(e.__e, t || null), t = e.__e);
    do {
        t = t && t.nextSibling
    } while (null != t && 8 === t.nodeType);
    return t
}

function Mi(e, t, n, r) {
    var i = e.key,
        s = e.type,
        a = n - 1,
        o = n + 1,
        c = t[n];
    if (null === c || c && i == c.key && s === c.type && !(131072 & c.__u)) return n;
    if (r > (null == c || 131072 & c.__u ? 0 : 1))
        for (; a >= 0 || o < t.length;) {
            if (a >= 0) {
                if ((c = t[a]) && !(131072 & c.__u) && i == c.key && s === c.type) return a;
                a--
            }
            if (o < t.length) {
                if ((c = t[o]) && !(131072 & c.__u) && i == c.key && s === c.type) return o;
                o++
            }
        }
    return -1
}

function Ri(e, t, n) {
    "-" === t[0] ? e.setProperty(t, null == n ? "" : n) : e[t] = null == n ? "" : "number" != typeof n || fi.test(t) ? n : n + "px"
}

function xi(e, t, n, r, i) {
    var s;
    e: if ("style" === t)
        if ("string" == typeof n) e.style.cssText = n;
        else {
            if ("string" == typeof r && (e.style.cssText = r = ""), r)
                for (t in r) n && t in n || Ri(e.style, t, "");
            if (n)
                for (t in n) r && n[t] === r[t] || Ri(e.style, t, n[t])
        }
    else if ("o" === t[0] && "n" === t[1]) s = t !== (t = t.replace(/(PointerCapture)$|Capture$/i, "$1")), t = t.toLowerCase() in e || "onFocusOut" === t || "onFocusIn" === t ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + s] = n, n ? r ? n.u = r.u : (n.u = oi, e.addEventListener(t, s ? li : ci, s)) : e.removeEventListener(t, s ? li : ci, s);
    else {
        if ("http://www.w3.org/2000/svg" == i) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" != t && "height" != t && "href" != t && "list" != t && "form" != t && "tabIndex" != t && "download" != t && "rowSpan" != t && "colSpan" != t && "role" != t && t in e) try {
            e[t] = null == n ? "" : n;
            break e
        } catch (a) {}
        "function" == typeof n || (null == n || !1 === n && "-" !== t[4] ? e.removeAttribute(t) : e.setAttribute(t, n))
    }
}

function Li(e) {
    return function(t) {
        if (this.l) {
            var n = this.l[t.type + e];
            if (null == t.t) t.t = oi++;
            else if (t.t < n.u) return;
            return n(ei.event ? ei.event(t) : t)
        }
    }
}

function Ai(e, t, n, r, i, s, a, o, c, l) {
    var u, d, h, f, p, _, g, m, b, y, v, w, E, S, k, C = t.type;
    if (void 0 !== t.constructor) return null;
    128 & n.__u && (c = !!(32 & n.__u), s = [o = t.__e = n.__e]), (u = ei.__b) && u(t);
    e: if ("function" == typeof C) try {
        if (m = t.props, b = (u = C.contextType) && r[u.__c], y = u ? b ? b.props.value : u.__ : r, n.__c ? g = (d = t.__c = n.__c).__ = d.__E : ("prototype" in C && C.prototype.render ? t.__c = d = new C(m, y) : (t.__c = d = new vi(m, y), d.constructor = C, d.render = Ni), b && b.sub(d), d.props = m, d.state || (d.state = {}), d.context = y, d.__n = r, h = d.__d = !0, d.__h = [], d._sb = []), null == d.__s && (d.__s = d.state), null != C.getDerivedStateFromProps && (d.__s == d.state && (d.__s = _i({}, d.__s)), _i(d.__s, C.getDerivedStateFromProps(m, d.__s))), f = d.props, p = d.state, d.__v = t, h) null == C.getDerivedStateFromProps && null != d.componentWillMount && d.componentWillMount(), null != d.componentDidMount && d.__h.push(d.componentDidMount);
        else {
            if (null == C.getDerivedStateFromProps && m !== f && null != d.componentWillReceiveProps && d.componentWillReceiveProps(m, y), !d.__e && (null != d.shouldComponentUpdate && !1 === d.shouldComponentUpdate(m, d.__s, y) || t.__v === n.__v)) {
                for (t.__v !== n.__v && (d.props = m, d.state = d.__s, d.__d = !1), t.__e = n.__e, t.__k = n.__k, t.__k.forEach((function(e) {
                        e && (e.__ = t)
                    })), v = 0; v < d._sb.length; v++) d.__h.push(d._sb[v]);
                d._sb = [], d.__h.length && a.push(d);
                break e
            }
            null != d.componentWillUpdate && d.componentWillUpdate(m, d.__s, y), null != d.componentDidUpdate && d.__h.push((function() {
                d.componentDidUpdate(f, p, _)
            }))
        }
        if (d.context = y, d.props = m, d.__P = e, d.__e = !1, w = ei.__r, E = 0, "prototype" in C && C.prototype.render) {
            for (d.state = d.__s, d.__d = !1, w && w(t), u = d.render(d.props, d.state, d.context), S = 0; S < d._sb.length; S++) d.__h.push(d._sb[S]);
            d._sb = []
        } else
            do {
                d.__d = !1, w && w(t), u = d.render(d.props, d.state, d.context), d.state = d.__s
            } while (d.__d && ++E < 25);
        d.state = d.__s, null != d.getChildContext && (r = _i(_i({}, r), d.getChildContext())), h || null == d.getSnapshotBeforeUpdate || (_ = d.getSnapshotBeforeUpdate(f, p)), Ci(e, pi(k = null != u && u.type === yi && null == u.key ? u.props.children : u) ? k : [k], t, n, r, i, s, a, o, c, l), d.base = t.__e, t.__u &= -161, d.__h.length && a.push(d), g && (d.__E = d.__ = null)
    } catch (I) {
        t.__v = null, c || null != s ? (t.__e = o, t.__u |= c ? 160 : 32, s[s.indexOf(o)] = null) : (t.__e = n.__e, t.__k = n.__k), ei.__e(I, t, n)
    } else null == s && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = function(e, t, n, r, i, s, a, o, c) {
        var l, u, d, h, f, p, _, g = n.props,
            m = t.props,
            b = t.type;
        if ("svg" === b ? i = "http://www.w3.org/2000/svg" : "math" === b ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), null != s)
            for (l = 0; l < s.length; l++)
                if ((f = s[l]) && "setAttribute" in f == !!b && (b ? f.localName === b : 3 === f.nodeType)) {
                    e = f, s[l] = null;
                    break
                }
        if (null == e) {
            if (null === b) return document.createTextNode(m);
            e = document.createElementNS(i, b, m.is && m), s = null, o = !1
        }
        if (null === b) g === m || o && e.data === m || (e.data = m);
        else {
            if (s = s && Xr.call(e.childNodes), g = n.props || di, !o && null != s)
                for (g = {}, l = 0; l < e.attributes.length; l++) g[(f = e.attributes[l]).name] = f.value;
            for (l in g)
                if (f = g[l], "children" == l);
                else if ("dangerouslySetInnerHTML" == l) d = f;
            else if ("key" !== l && !(l in m)) {
                if ("value" == l && "defaultValue" in m || "checked" == l && "defaultChecked" in m) continue;
                xi(e, l, null, f, i)
            }
            for (l in m) f = m[l], "children" == l ? h = f : "dangerouslySetInnerHTML" == l ? u = f : "value" == l ? p = f : "checked" == l ? _ = f : "key" === l || o && "function" != typeof f || g[l] === f || xi(e, l, f, g[l], i);
            if (u) o || d && (u.__html === d.__html || u.__html === e.innerHTML) || (e.innerHTML = u.__html), t.__k = [];
            else if (d && (e.innerHTML = ""), Ci(e, pi(h) ? h : [h], t, n, r, "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : i, s, a, s ? s[0] : n.__k && wi(n, 0), o, c), null != s)
                for (l = s.length; l--;) null != s[l] && gi(s[l]);
            o || (l = "value", void 0 !== p && (p !== e[l] || "progress" === b && !p || "option" === b && p !== g[l]) && xi(e, l, p, g[l], i), l = "checked", void 0 !== _ && _ !== e[l] && xi(e, l, _, g[l], i))
        }
        return e
    }(n.__e, t, n, r, i, s, a, c, l);
    (u = ei.diffed) && u(t)
}

function Pi(e, t, n) {
    t.__d = void 0;
    for (var r = 0; r < n.length; r++) Ti(n[r], n[++r], n[++r]);
    ei.__c && ei.__c(t, e), e.some((function(t) {
        try {
            e = t.__h, t.__h = [], e.some((function(e) {
                e.call(t)
            }))
        } catch (n) {
            ei.__e(n, t.__v)
        }
    }))
}

function Ti(e, t, n) {
    try {
        "function" == typeof e ? e(t) : e.current = t
    } catch (r) {
        ei.__e(r, n)
    }
}

function ji(e, t, n) {
    var r, i;
    if (ei.unmount && ei.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || Ti(r, null, t)), null != (r = e.__c)) {
        if (r.componentWillUnmount) try {
            r.componentWillUnmount()
        } catch (s) {
            ei.__e(s, t)
        }
        r.base = r.__P = null
    }
    if (r = e.__k)
        for (i = 0; i < r.length; i++) r[i] && ji(r[i], t, n || "function" != typeof e.type);
    n || null == e.__e || gi(e.__e), e.__c = e.__ = e.__e = e.__d = void 0
}

function Ni(e, t, n) {
    return this.constructor(e, n)
}

function Oi(e, t, n) {
    var r, i, s, a;
    ei.__ && ei.__(e, t), i = (r = "function" == typeof n) ? null : n && n.__k || t.__k, s = [], a = [], Ai(t, e = (!r && n || t).__k = mi(yi, null, [e]), i || di, di, t.namespaceURI, !r && n ? [n] : i ? null : t.firstChild ? Xr.call(t.childNodes) : null, s, !r && n ? n : i ? i.__e : t.firstChild, r, a), Pi(s, e, a)
}
Xr = hi.slice, ei = {
    __e: function(e, t, n, r) {
        for (var i, s, a; t = t.__;)
            if ((i = t.__c) && !i.__) try {
                if ((s = i.constructor) && null != s.getDerivedStateFromError && (i.setState(s.getDerivedStateFromError(e)), a = i.__d), null != i.componentDidCatch && (i.componentDidCatch(e, r || {}), a = i.__d), a) return i.__E = i
            } catch (o) {
                e = o
            }
        throw e
    }
}, ti = 0, ni = function(e) {
    return null != e && null == e.constructor
}, vi.prototype.setState = function(e, t) {
    var n;
    n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = _i({}, this.state), "function" == typeof e && (e = e(_i({}, n), this.props)), e && _i(n, e), null != e && this.__v && (t && this._sb.push(t), Si(this))
}, vi.prototype.forceUpdate = function(e) {
    this.__v && (this.__e = !0, e && this.__h.push(e), Si(this))
}, vi.prototype.render = yi, ri = [], si = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, ai = function(e, t) {
    return e.__v.__b - t.__v.__b
}, ki.__r = 0, oi = 0, ci = Li(!1), li = Li(!0), ui = 0;
const Di = Object.freeze(Object.defineProperty({
        __proto__: null,
        Component: vi,
        Fragment: yi,
        cloneElement: function(e, t, n) {
            var r, i, s, a, o = _i({}, e.props);
            for (s in e.type && e.type.defaultProps && (a = e.type.defaultProps), t) "key" == s ? r = t[s] : "ref" == s ? i = t[s] : o[s] = void 0 === t[s] && void 0 !== a ? a[s] : t[s];
            return arguments.length > 2 && (o.children = arguments.length > 3 ? Xr.call(arguments, 2) : n), bi(e.type, o, r || e.key, i || e.ref, null)
        },
        createContext: function(e, t) {
            var n = {
                __c: t = "__cC" + ui++,
                __: e,
                Consumer: function(e, t) {
                    return e.children(t)
                },
                Provider: function(e) {
                    var n, r;
                    return this.getChildContext || (n = [], (r = {})[t] = this, this.getChildContext = function() {
                        return r
                    }, this.shouldComponentUpdate = function(e) {
                        this.props.value !== e.value && n.some((function(e) {
                            e.__e = !0, Si(e)
                        }))
                    }, this.sub = function(e) {
                        n.push(e);
                        var t = e.componentWillUnmount;
                        e.componentWillUnmount = function() {
                            n.splice(n.indexOf(e), 1), t && t.call(e)
                        }
                    }), e.children
                }
            };
            return n.Provider.__ = n.Consumer.contextType = n
        },
        createElement: mi,
        createRef: function() {
            return {
                current: null
            }
        },
        h: mi,
        hydrate: function e(t, n) {
            Oi(t, n, e)
        },
        get isValidElement() {
            return ni
        },
        get options() {
            return ei
        },
        render: Oi,
        toChildArray: function e(t, n) {
            return n = n || [], null == t || "boolean" == typeof t || (pi(t) ? t.some((function(t) {
                e(t, n)
            })) : n.push(t)), n
        }
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Bi = n(Di);
var Ui, Wi, qi, Hi, Fi = 0,
    zi = [],
    Vi = [],
    Ki = ei,
    Zi = Ki.__b,
    Gi = Ki.__r,
    $i = Ki.diffed,
    Yi = Ki.__c,
    Ji = Ki.unmount,
    Qi = Ki.__;

function Xi(e, t) {
    Ki.__h && Ki.__h(Wi, e, Fi || t), Fi = 0;
    var n = Wi.__H || (Wi.__H = {
        __: [],
        __h: []
    });
    return e >= n.__.length && n.__.push({
        __V: Vi
    }), n.__[e]
}

function es(e) {
    return Fi = 1, ts(us, e)
}

function ts(e, t, n) {
    var r = Xi(Ui++, 2);
    if (r.t = e, !r.__c && (r.__ = [n ? n(t) : us(void 0, t), function(e) {
            var t = r.__N ? r.__N[0] : r.__[0],
                n = r.t(t, e);
            t !== n && (r.__N = [n, r.__[1]], r.__c.setState({}))
        }], r.__c = Wi, !Wi.u)) {
        var i = function(e, t, n) {
            if (!r.__c.__H) return !0;
            var i = r.__c.__H.__.filter((function(e) {
                return !!e.__c
            }));
            if (i.every((function(e) {
                    return !e.__N
                }))) return !s || s.call(this, e, t, n);
            var a = !1;
            return i.forEach((function(e) {
                if (e.__N) {
                    var t = e.__[0];
                    e.__ = e.__N, e.__N = void 0, t !== e.__[0] && (a = !0)
                }
            })), !(!a && r.__c.props === e) && (!s || s.call(this, e, t, n))
        };
        Wi.u = !0;
        var s = Wi.shouldComponentUpdate,
            a = Wi.componentWillUpdate;
        Wi.componentWillUpdate = function(e, t, n) {
            if (this.__e) {
                var r = s;
                s = void 0, i(e, t, n), s = r
            }
            a && a.call(this, e, t, n)
        }, Wi.shouldComponentUpdate = i
    }
    return r.__N || r.__
}

function ns(e, t) {
    var n = Xi(Ui++, 4);
    !Ki.__s && ls(n.__H, t) && (n.__ = e, n.i = t, Wi.__h.push(n))
}

function rs(e, t) {
    var n = Xi(Ui++, 7);
    return ls(n.__H, t) ? (n.__V = e(), n.i = t, n.__h = e, n.__V) : n.__
}

function is() {
    for (var e; e = zi.shift();)
        if (e.__P && e.__H) try {
            e.__H.__h.forEach(os), e.__H.__h.forEach(cs), e.__H.__h = []
        } catch (t) {
            e.__H.__h = [], Ki.__e(t, e.__v)
        }
}
Ki.__b = function(e) {
    Wi = null, Zi && Zi(e)
}, Ki.__ = function(e, t) {
    e && t.__k && t.__k.__m && (e.__m = t.__k.__m), Qi && Qi(e, t)
}, Ki.__r = function(e) {
    Gi && Gi(e), Ui = 0;
    var t = (Wi = e.__c).__H;
    t && (qi === Wi ? (t.__h = [], Wi.__h = [], t.__.forEach((function(e) {
        e.__N && (e.__ = e.__N), e.__V = Vi, e.__N = e.i = void 0
    }))) : (t.__h.forEach(os), t.__h.forEach(cs), t.__h = [], Ui = 0)), qi = Wi
}, Ki.diffed = function(e) {
    $i && $i(e);
    var t = e.__c;
    t && t.__H && (t.__H.__h.length && (1 !== zi.push(t) && Hi === Ki.requestAnimationFrame || ((Hi = Ki.requestAnimationFrame) || as)(is)), t.__H.__.forEach((function(e) {
        e.i && (e.__H = e.i), e.__V !== Vi && (e.__ = e.__V), e.i = void 0, e.__V = Vi
    }))), qi = Wi = null
}, Ki.__c = function(e, t) {
    t.some((function(e) {
        try {
            e.__h.forEach(os), e.__h = e.__h.filter((function(e) {
                return !e.__ || cs(e)
            }))
        } catch (n) {
            t.some((function(e) {
                e.__h && (e.__h = [])
            })), t = [], Ki.__e(n, e.__v)
        }
    })), Yi && Yi(e, t)
}, Ki.unmount = function(e) {
    Ji && Ji(e);
    var t, n = e.__c;
    n && n.__H && (n.__H.__.forEach((function(e) {
        try {
            os(e)
        } catch (n) {
            t = n
        }
    })), n.__H = void 0, t && Ki.__e(t, n.__v))
};
var ss = "function" == typeof requestAnimationFrame;

function as(e) {
    var t, n = function() {
            clearTimeout(r), ss && cancelAnimationFrame(t), setTimeout(e)
        },
        r = setTimeout(n, 100);
    ss && (t = requestAnimationFrame(n))
}

function os(e) {
    var t = Wi,
        n = e.__c;
    "function" == typeof n && (e.__c = void 0, n()), Wi = t
}

function cs(e) {
    var t = Wi;
    e.__c = e.__(), Wi = t
}

function ls(e, t) {
    return !e || e.length !== t.length || t.some((function(t, n) {
        return t !== e[n]
    }))
}

function us(e, t) {
    return "function" == typeof t ? t(e) : t
}
const ds = n(Object.freeze(Object.defineProperty({
    __proto__: null,
    useCallback: function(e, t) {
        return Fi = 8, rs((function() {
            return e
        }), t)
    },
    useContext: function(e) {
        var t = Wi.context[e.__c],
            n = Xi(Ui++, 9);
        return n.c = e, t ? (null == n.__ && (n.__ = !0, t.sub(Wi)), t.props.value) : e.__
    },
    useDebugValue: function(e, t) {
        Ki.useDebugValue && Ki.useDebugValue(t ? t(e) : e)
    },
    useEffect: function(e, t) {
        var n = Xi(Ui++, 3);
        !Ki.__s && ls(n.__H, t) && (n.__ = e, n.i = t, Wi.__H.__h.push(n))
    },
    useErrorBoundary: function(e) {
        var t = Xi(Ui++, 10),
            n = es();
        return t.__ = e, Wi.componentDidCatch || (Wi.componentDidCatch = function(e, r) {
            t.__ && t.__(e, r), n[1](e)
        }), [n[0], function() {
            n[1](void 0)
        }]
    },
    useId: function() {
        var e = Xi(Ui++, 11);
        if (!e.__) {
            for (var t = Wi.__v; null !== t && !t.__m && null !== t.__;) t = t.__;
            var n = t.__m || (t.__m = [0, 0]);
            e.__ = "P" + n[0] + "-" + n[1]++
        }
        return e.__
    },
    useImperativeHandle: function(e, t, n) {
        Fi = 6, ns((function() {
            return "function" == typeof e ? (e(t()), function() {
                return e(null)
            }) : e ? (e.current = t(), function() {
                return e.current = null
            }) : void 0
        }), null == n ? n : n.concat(e))
    },
    useLayoutEffect: ns,
    useMemo: rs,
    useReducer: ts,
    useRef: function(e) {
        return Fi = 5, rs((function() {
            return {
                current: e
            }
        }), [])
    },
    useState: es
}, Symbol.toStringTag, {
    value: "Module"
})));
var hs = {};
Object.defineProperty(hs, "__esModule", {
        value: !0
    }), hs.default = (() => ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}")(),
    function(e) {
        var n = t && t.__importDefault || function(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        };
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.SnackbarInstance = e.SnackbarContainer = e.Snackbar = void 0;
        const r = n(Qr),
            i = Bi,
            s = ds,
            a = Fr,
            o = n(hs);
        e.Snackbar = class {
            constructor() {
                this.items = new Map, this.nextItemKey = 0, this.root = null, this.darkMode = (0, a.isDarkMode)()
            }
            attach(e) {
                this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", e.appendChild(this.root), this.render()
            }
            presentItem(e) {
                const t = this.nextItemKey++;
                return this.items.set(t, e), this.render(), () => {
                    this.items.delete(t), this.render()
                }
            }
            clear() {
                this.items.clear(), this.render()
            }
            render() {
                this.root && (0, i.render)((0, i.h)("div", null, (0, i.h)(e.SnackbarContainer, {
                    darkMode: this.darkMode
                }, Array.from(this.items.entries()).map((([t, n]) => (0, i.h)(e.SnackbarInstance, Object.assign({}, n, {
                    key: t
                })))))), this.root)
            }
        };
        e.SnackbarContainer = e => (0, i.h)("div", {
            class: (0, r.default)("-cbwsdk-snackbar-container")
        }, (0, i.h)("style", null, o.default), (0, i.h)("div", {
            class: "-cbwsdk-snackbar"
        }, e.children));
        e.SnackbarInstance = ({
            autoExpand: e,
            message: t,
            menuItems: n
        }) => {
            const [a, o] = (0, s.useState)(!0), [c, l] = (0, s.useState)(null != e && e);
            (0, s.useEffect)((() => {
                const e = [window.setTimeout((() => {
                    o(!1)
                }), 1), window.setTimeout((() => {
                    l(!0)
                }), 1e4)];
                return () => {
                    e.forEach(window.clearTimeout)
                }
            }));
            return (0, i.h)("div", {
                class: (0, r.default)("-cbwsdk-snackbar-instance", a && "-cbwsdk-snackbar-instance-hidden", c && "-cbwsdk-snackbar-instance-expanded")
            }, (0, i.h)("div", {
                class: "-cbwsdk-snackbar-instance-header",
                onClick: () => {
                    l(!c)
                }
            }, (0, i.h)("img", {
                src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+",
                class: "-cbwsdk-snackbar-instance-header-cblogo"
            }), " ", (0, i.h)("div", {
                class: "-cbwsdk-snackbar-instance-header-message"
            }, t), (0, i.h)("div", {
                class: "-gear-container"
            }, !c && (0, i.h)("svg", {
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
            }, (0, i.h)("circle", {
                cx: "12",
                cy: "12",
                r: "12",
                fill: "#F5F7F8"
            })), (0, i.h)("img", {
                src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=",
                class: "-gear-icon",
                title: "Expand"
            }))), n && n.length > 0 && (0, i.h)("div", {
                class: "-cbwsdk-snackbar-instance-menu"
            }, n.map(((e, t) => (0, i.h)("div", {
                class: (0, r.default)("-cbwsdk-snackbar-instance-menu-item", e.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"),
                onClick: e.onClick,
                key: t
            }, (0, i.h)("svg", {
                width: e.svgWidth,
                height: e.svgHeight,
                viewBox: "0 0 10 11",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
            }, (0, i.h)("path", {
                "fill-rule": e.defaultFillRule,
                "clip-rule": e.defaultClipRule,
                d: e.path,
                fill: "#AAAAAA"
            })), (0, i.h)("span", {
                class: (0, r.default)("-cbwsdk-snackbar-instance-menu-item-info", e.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red")
            }, e.info))))))
        }
    }($r), Object.defineProperty(zr, "__esModule", {
        value: !0
    }), zr.WalletLinkRelayUI = void 0;
const fs = Vr,
    ps = $r;
zr.WalletLinkRelayUI = class {
    constructor() {
        this.attached = !1, this.snackbar = new ps.Snackbar
    }
    attach() {
        if (this.attached) throw new Error("Coinbase Wallet SDK UI is already attached");
        const e = document.documentElement,
            t = document.createElement("div");
        t.className = "-cbwsdk-css-reset", e.appendChild(t), this.snackbar.attach(t), this.attached = !0, (0, fs.injectCssReset)()
    }
    showConnecting(e) {
        let t;
        return t = e.isUnlinkedErrorState ? {
            autoExpand: !0,
            message: "Connection lost",
            menuItems: [{
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection
            }]
        } : {
            message: "Confirm on phone",
            menuItems: [{
                isRed: !0,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: e.onCancel
            }, {
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection
            }]
        }, this.snackbar.presentItem(t)
    }
};
var _s = {},
    gs = {},
    ms = {};
Object.defineProperty(ms, "__esModule", {
    value: !0
}), ms.default = (() => ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}")();
var bs = t && t.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
};
Object.defineProperty(gs, "__esModule", {
    value: !0
}), gs.RedirectDialog = void 0;
const ys = bs(Qr),
    vs = Bi,
    ws = Vr,
    Es = $r,
    Ss = Fr,
    ks = bs(ms);
gs.RedirectDialog = class {
    constructor() {
        this.root = null, this.darkMode = (0, Ss.isDarkMode)()
    }
    attach() {
        const e = document.documentElement;
        this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", e.appendChild(this.root), (0, ws.injectCssReset)()
    }
    present(e) {
        this.render(e)
    }
    clear() {
        this.render(null)
    }
    render(e) {
        this.root && ((0, vs.render)(null, this.root), e && (0, vs.render)((0, vs.h)(Cs, Object.assign({}, e, {
            onDismiss: () => {
                this.clear()
            },
            darkMode: this.darkMode
        })), this.root))
    }
};
const Cs = ({
    title: e,
    buttonText: t,
    darkMode: n,
    onButtonClick: r,
    onDismiss: i
}) => {
    const s = n ? "dark" : "light";
    return (0, vs.h)(Es.SnackbarContainer, {
        darkMode: n
    }, (0, vs.h)("div", {
        class: "-cbwsdk-redirect-dialog"
    }, (0, vs.h)("style", null, ks.default), (0, vs.h)("div", {
        class: "-cbwsdk-redirect-dialog-backdrop",
        onClick: i
    }), (0, vs.h)("div", {
        class: (0, ys.default)("-cbwsdk-redirect-dialog-box", s)
    }, (0, vs.h)("p", null, e), (0, vs.h)("button", {
        onClick: r
    }, t))))
};
var Is = {};
Object.defineProperty(Is, "__esModule", {
    value: !0
}), Is.CBW_MOBILE_DEEPLINK_URL = Is.WALLETLINK_URL = Is.CB_KEYS_URL = void 0, Is.CB_KEYS_URL = "https://keys.coinbase.com/connect", Is.WALLETLINK_URL = "https://www.walletlink.org", Is.CBW_MOBILE_DEEPLINK_URL = "https://go.cb-w.com/walletlink", Object.defineProperty(_s, "__esModule", {
    value: !0
}), _s.WLMobileRelayUI = void 0;
const Ms = gs,
    Rs = Fr,
    xs = Is;
_s.WLMobileRelayUI = class {
    constructor() {
        this.attached = !1, this.redirectDialog = new Ms.RedirectDialog
    }
    attach() {
        if (this.attached) throw new Error("Coinbase Wallet SDK UI is already attached");
        this.redirectDialog.attach(), this.attached = !0
    }
    redirectToCoinbaseWallet(e) {
        const t = new URL(xs.CBW_MOBILE_DEEPLINK_URL);
        t.searchParams.append("redirect_url", (0, Rs.getLocation)().href), e && t.searchParams.append("wl_url", e);
        const n = document.createElement("a");
        n.target = "cbw-opener", n.href = t.href, n.rel = "noreferrer noopener", n.click()
    }
    openCoinbaseWalletDeeplink(e) {
        this.redirectDialog.present({
            title: "Redirecting to Coinbase Wallet...",
            buttonText: "Open",
            onButtonClick: () => {
                this.redirectToCoinbaseWallet(e)
            }
        }), setTimeout((() => {
            this.redirectToCoinbaseWallet(e)
        }), 99)
    }
    showConnecting(e) {
        return () => {
            this.redirectDialog.clear()
        }
    }
}, Object.defineProperty(un, "__esModule", {
    value: !0
}), un.WalletLinkRelay = void 0;
const Ls = dn,
    As = on,
    Ps = cn,
    Ts = Sn,
    js = k,
    Ns = Fr,
    Os = zr,
    Ds = _s,
    Bs = h,
    Us = P,
    Ws = ee;
class qs {
    constructor(e) {
        this.accountsCallback = null, this.chainCallbackParams = {
            chainId: "",
            jsonRpcUrl: ""
        }, this.chainCallback = null, this.dappDefaultChain = 1, this.isMobileWeb = (0, Ns.isMobileWeb)(), this.appName = "", this.appLogoUrl = null, this.linkedUpdated = e => {
            this.isLinked = e;
            const t = this.storage.getItem(As.LOCAL_STORAGE_ADDRESSES_KEY);
            if (e && (this._session.linked = e), this.isUnlinkedErrorState = !1, t) {
                const n = t.split(" "),
                    r = "true" === this.storage.getItem("IsStandaloneSigning");
                "" === n[0] || e || !this._session.linked || r || (this.isUnlinkedErrorState = !0)
            }
        }, this.metadataUpdated = (e, t) => {
            this.storage.setItem(e, t)
        }, this.chainUpdated = (e, t) => {
            this.chainCallbackParams.chainId === e && this.chainCallbackParams.jsonRpcUrl === t || (this.chainCallbackParams = {
                chainId: e,
                jsonRpcUrl: t
            }, this.chainCallback && this.chainCallback(e, t))
        }, this.accountUpdated = e => {
            this.accountsCallback && this.accountsCallback([e]), qs.accountRequestCallbackIds.size > 0 && (Array.from(qs.accountRequestCallbackIds.values()).forEach((t => {
                const n = {
                    type: "WEB3_RESPONSE",
                    id: t,
                    response: {
                        method: "requestEthereumAccounts",
                        result: [e]
                    }
                };
                this.invokeCallback(Object.assign(Object.assign({}, n), {
                    id: t
                }))
            })), qs.accountRequestCallbackIds.clear())
        }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage;
        const {
            session: t,
            ui: n,
            connection: r
        } = this.subscribe();
        this._session = t, this.connection = r, this.relayEventManager = new Ps.RelayEventManager, this.ui = n
    }
    subscribe() {
        const e = Ts.WalletLinkSession.load(this.storage) || new Ts.WalletLinkSession(this.storage).save(),
            {
                linkAPIUrl: t
            } = this,
            n = new Ls.WalletLinkConnection({
                session: e,
                linkAPIUrl: t,
                listener: this
            }),
            r = this.isMobileWeb ? new Ds.WLMobileRelayUI : new Os.WalletLinkRelayUI;
        return n.connect(), {
            session: e,
            ui: r,
            connection: n
        }
    }
    attachUI() {
        this.ui.attach()
    }
    resetAndReload() {
        Promise.race([this.connection.setSessionMetadata("__destroyed", "1"), new Promise((e => setTimeout((() => e(null)), 1e3)))]).then((() => {
            this.connection.destroy();
            const e = Ts.WalletLinkSession.load(this.storage);
            (null == e ? void 0 : e.id) === this._session.id && Ws.ScopedLocalStorage.clearAll(), document.location.reload()
        })).catch((e => {}))
    }
    setAppInfo(e, t) {
        this.appName = e, this.appLogoUrl = t
    }
    getStorageItem(e) {
        return this.storage.getItem(e)
    }
    setStorageItem(e, t) {
        this.storage.setItem(e, t)
    }
    signEthereumMessage(e, t, n, r) {
        return this.sendRequest({
            method: "signEthereumMessage",
            params: {
                message: (0, Us.hexStringFromBuffer)(e, !0),
                address: t,
                addPrefix: n,
                typedDataJson: r || null
            }
        })
    }
    ethereumAddressFromSignedMessage(e, t, n) {
        return this.sendRequest({
            method: "ethereumAddressFromSignedMessage",
            params: {
                message: (0, Us.hexStringFromBuffer)(e, !0),
                signature: (0, Us.hexStringFromBuffer)(t, !0),
                addPrefix: n
            }
        })
    }
    signEthereumTransaction(e) {
        return this.sendRequest({
            method: "signEthereumTransaction",
            params: {
                fromAddress: e.fromAddress,
                toAddress: e.toAddress,
                weiValue: (0, Us.bigIntStringFromBigInt)(e.weiValue),
                data: (0, Us.hexStringFromBuffer)(e.data, !0),
                nonce: e.nonce,
                gasPriceInWei: e.gasPriceInWei ? (0, Us.bigIntStringFromBigInt)(e.gasPriceInWei) : null,
                maxFeePerGas: e.gasPriceInWei ? (0, Us.bigIntStringFromBigInt)(e.gasPriceInWei) : null,
                maxPriorityFeePerGas: e.gasPriceInWei ? (0, Us.bigIntStringFromBigInt)(e.gasPriceInWei) : null,
                gasLimit: e.gasLimit ? (0, Us.bigIntStringFromBigInt)(e.gasLimit) : null,
                chainId: e.chainId,
                shouldSubmit: !1
            }
        })
    }
    signAndSubmitEthereumTransaction(e) {
        return this.sendRequest({
            method: "signEthereumTransaction",
            params: {
                fromAddress: e.fromAddress,
                toAddress: e.toAddress,
                weiValue: (0, Us.bigIntStringFromBigInt)(e.weiValue),
                data: (0, Us.hexStringFromBuffer)(e.data, !0),
                nonce: e.nonce,
                gasPriceInWei: e.gasPriceInWei ? (0, Us.bigIntStringFromBigInt)(e.gasPriceInWei) : null,
                maxFeePerGas: e.maxFeePerGas ? (0, Us.bigIntStringFromBigInt)(e.maxFeePerGas) : null,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas ? (0, Us.bigIntStringFromBigInt)(e.maxPriorityFeePerGas) : null,
                gasLimit: e.gasLimit ? (0, Us.bigIntStringFromBigInt)(e.gasLimit) : null,
                chainId: e.chainId,
                shouldSubmit: !0
            }
        })
    }
    submitEthereumTransaction(e, t) {
        return this.sendRequest({
            method: "submitEthereumTransaction",
            params: {
                signedTransaction: (0, Us.hexStringFromBuffer)(e, !0),
                chainId: t
            }
        })
    }
    scanQRCode(e) {
        return this.sendRequest({
            method: "scanQRCode",
            params: {
                regExp: e
            }
        })
    }
    getWalletLinkSession() {
        return this._session
    }
    genericRequest(e, t) {
        return this.sendRequest({
            method: "generic",
            params: {
                action: t,
                data: e
            }
        })
    }
    sendGenericMessage(e) {
        return this.sendRequest(e)
    }
    sendRequest(e) {
        let t = null;
        const n = (0, Us.randomBytesHex)(8),
            r = r => {
                this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, r), null == t || t()
            };
        return new Promise(((i, s) => {
            t = this.ui.showConnecting({
                isUnlinkedErrorState: this.isUnlinkedErrorState,
                onCancel: r,
                onResetConnection: this.resetAndReload
            }), this.relayEventManager.callbacks.set(n, (e => {
                if (null == t || t(), (0, js.isErrorResponse)(e)) return s(new Error(e.errorMessage));
                i(e)
            })), this.publishWeb3RequestEvent(n, e)
        }))
    }
    setAccountsCallback(e) {
        this.accountsCallback = e
    }
    setChainCallback(e) {
        this.chainCallback = e
    }
    setDappDefaultChainCallback(e) {
        this.dappDefaultChain = e
    }
    publishWeb3RequestEvent(e, t) {
        const n = {
            type: "WEB3_REQUEST",
            id: e,
            request: t
        };
        this.publishEvent("Web3Request", n, !0).then((e => {})).catch((e => {
            this.handleWeb3ResponseMessage({
                type: "WEB3_RESPONSE",
                id: n.id,
                response: {
                    method: t.method,
                    errorMessage: e.message
                }
            })
        })), this.isMobileWeb && this.openCoinbaseWalletDeeplink(t.method)
    }
    openCoinbaseWalletDeeplink(e) {
        if (this.ui instanceof Ds.WLMobileRelayUI) switch (e) {
            case "requestEthereumAccounts":
            case "switchEthereumChain":
                return;
            default:
                window.addEventListener("blur", (() => {
                    window.addEventListener("focus", (() => {
                        this.connection.checkUnseenEvents()
                    }), {
                        once: !0
                    })
                }), {
                    once: !0
                }), this.ui.openCoinbaseWalletDeeplink()
        }
    }
    publishWeb3RequestCanceledEvent(e) {
        const t = {
            type: "WEB3_REQUEST_CANCELED",
            id: e
        };
        this.publishEvent("Web3RequestCanceled", t, !1).then()
    }
    publishEvent(e, t, n) {
        return this.connection.publishEvent(e, t, n)
    }
    handleWeb3ResponseMessage(e) {
        const {
            response: t
        } = e;
        if ("requestEthereumAccounts" === t.method) return qs.accountRequestCallbackIds.forEach((t => this.invokeCallback(Object.assign(Object.assign({}, e), {
            id: t
        })))), void qs.accountRequestCallbackIds.clear();
        this.invokeCallback(e)
    }
    handleErrorResponse(e, t, n) {
        var r;
        const i = null !== (r = null == n ? void 0 : n.message) && void 0 !== r ? r : "Unspecified error message.";
        this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: e,
            response: {
                method: t,
                errorMessage: i
            }
        })
    }
    invokeCallback(e) {
        const t = this.relayEventManager.callbacks.get(e.id);
        t && (t(e.response), this.relayEventManager.callbacks.delete(e.id))
    }
    requestEthereumAccounts() {
        const e = {
                method: "requestEthereumAccounts",
                params: {
                    appName: this.appName,
                    appLogoUrl: this.appLogoUrl || null
                }
            },
            t = (0, Us.randomBytesHex)(8);
        return new Promise(((n, r) => {
            this.relayEventManager.callbacks.set(t, (e => {
                if ((0, js.isErrorResponse)(e)) return r(new Error(e.errorMessage));
                n(e)
            })), qs.accountRequestCallbackIds.add(t), this.publishWeb3RequestEvent(t, e)
        }))
    }
    watchAsset(e, t, n, r, i, s) {
        const a = {
            method: "watchAsset",
            params: {
                type: e,
                options: {
                    address: t,
                    symbol: n,
                    decimals: r,
                    image: i
                },
                chainId: s
            }
        };
        let o = null;
        const c = (0, Us.randomBytesHex)(8),
            l = e => {
                this.publishWeb3RequestCanceledEvent(c), this.handleErrorResponse(c, a.method, e), null == o || o()
            };
        return o = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: l,
            onResetConnection: this.resetAndReload
        }), new Promise(((e, t) => {
            this.relayEventManager.callbacks.set(c, (n => {
                if (null == o || o(), (0, js.isErrorResponse)(n)) return t(new Error(n.errorMessage));
                e(n)
            })), this.publishWeb3RequestEvent(c, a)
        }))
    }
    addEthereumChain(e, t, n, r, i, s) {
        const a = {
            method: "addEthereumChain",
            params: {
                chainId: e,
                rpcUrls: t,
                blockExplorerUrls: r,
                chainName: i,
                iconUrls: n,
                nativeCurrency: s
            }
        };
        let o = null;
        const c = (0, Us.randomBytesHex)(8),
            l = e => {
                this.publishWeb3RequestCanceledEvent(c), this.handleErrorResponse(c, a.method, e), null == o || o()
            };
        return o = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: l,
            onResetConnection: this.resetAndReload
        }), new Promise(((e, t) => {
            this.relayEventManager.callbacks.set(c, (n => {
                if (null == o || o(), (0, js.isErrorResponse)(n)) return t(new Error(n.errorMessage));
                e(n)
            })), this.publishWeb3RequestEvent(c, a)
        }))
    }
    switchEthereumChain(e, t) {
        const n = {
                method: "switchEthereumChain",
                params: Object.assign({
                    chainId: e
                }, {
                    address: t
                })
            },
            r = (0, Us.randomBytesHex)(8);
        return new Promise(((e, t) => {
            this.relayEventManager.callbacks.set(r, (n => (0, js.isErrorResponse)(n) && n.errorCode ? t(Bs.standardErrors.provider.custom({
                code: n.errorCode,
                message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
            })) : (0, js.isErrorResponse)(n) ? t(new Error(n.errorMessage)) : void e(n))), this.publishWeb3RequestEvent(r, n)
        }))
    }
}
un.WalletLinkRelay = qs, qs.accountRequestCallbackIds = new Set;
var Hs = t && t.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
};
Object.defineProperty(ve, "__esModule", {
    value: !0
}), ve.WalletLinkSigner = void 0;
const Fs = Hs(an),
    zs = on,
    Vs = cn,
    Ks = k,
    Zs = un,
    Gs = Is,
    $s = h,
    Ys = P,
    Js = ee,
    Qs = "DefaultChainId",
    Xs = "DefaultJsonRpcUrl";
ve.WalletLinkSigner = class {
    constructor(e) {
        var t, n;
        this._relay = null, this._addresses = [], this.hasMadeFirstChainChangedEmission = !1;
        const {
            appName: r,
            appLogoUrl: i
        } = e.metadata;
        this._appName = r, this._appLogoUrl = i, this._storage = new Js.ScopedLocalStorage("walletlink", Gs.WALLETLINK_URL), this.updateListener = e.updateListener, this._relayEventManager = new Vs.RelayEventManager, this._jsonRpcUrlFromOpts = "";
        const s = this._storage.getItem(zs.LOCAL_STORAGE_ADDRESSES_KEY);
        if (s) {
            const e = s.split(" ");
            "" !== e[0] && (this._addresses = e.map((e => (0, Ys.ensureAddressString)(e))), null === (t = this.updateListener) || void 0 === t || t.onAccountsUpdate({
                accounts: this._addresses,
                source: "storage"
            }))
        }
        this._storage.getItem(Qs) && (null === (n = this.updateListener) || void 0 === n || n.onChainUpdate({
            chain: {
                id: this.getChainId(),
                rpcUrl: this.jsonRpcUrl
            },
            source: "storage"
        }), this.hasMadeFirstChainChangedEmission = !0), this.initializeRelay()
    }
    getSession() {
        const e = this.initializeRelay(),
            {
                id: t,
                secret: n
            } = e.getWalletLinkSession();
        return {
            id: t,
            secret: n
        }
    }
    async handshake() {
        return await this.request({
            method: "eth_requestAccounts"
        })
    }
    get selectedAddress() {
        return this._addresses[0] || void 0
    }
    get jsonRpcUrl() {
        var e;
        return null !== (e = this._storage.getItem(Xs)) && void 0 !== e ? e : this._jsonRpcUrlFromOpts
    }
    set jsonRpcUrl(e) {
        this._storage.setItem(Xs, e)
    }
    updateProviderInfo(e, t) {
        var n;
        this.jsonRpcUrl = e;
        const r = this.getChainId();
        this._storage.setItem(Qs, t.toString(10));
        !((0, Ys.ensureIntNumber)(t) !== r) && this.hasMadeFirstChainChangedEmission || (null === (n = this.updateListener) || void 0 === n || n.onChainUpdate({
            chain: {
                id: t,
                rpcUrl: e
            },
            source: "wallet"
        }), this.hasMadeFirstChainChangedEmission = !0)
    }
    async watchAsset(e, t, n, r, i, s) {
        const a = this.initializeRelay(),
            o = await a.watchAsset(e, t, n, r, i, null == s ? void 0 : s.toString());
        return !(0, Ks.isErrorResponse)(o) && !!o.result
    }
    async addEthereumChain(e, t, n, r, i, s) {
        var a, o;
        if ((0, Ys.ensureIntNumber)(e) === this.getChainId()) return !1;
        const c = this.initializeRelay();
        this._isAuthorized() || await c.requestEthereumAccounts();
        const l = await c.addEthereumChain(e.toString(), t, i, n, r, s);
        return !(0, Ks.isErrorResponse)(l) && (!0 === (null === (a = l.result) || void 0 === a ? void 0 : a.isApproved) && this.updateProviderInfo(t[0], e), !0 === (null === (o = l.result) || void 0 === o ? void 0 : o.isApproved))
    }
    async switchEthereumChain(e) {
        const t = this.initializeRelay(),
            n = await t.switchEthereumChain(e.toString(10), this.selectedAddress || void 0);
        if ((0, Ks.isErrorResponse)(n)) {
            if (!n.errorCode) return;
            throw n.errorCode === $s.standardErrorCodes.provider.unsupportedChain ? $s.standardErrors.provider.unsupportedChain() : $s.standardErrors.provider.custom({
                message: n.errorMessage,
                code: n.errorCode
            })
        }
        const r = n.result;
        r.isApproved && r.rpcUrl.length > 0 && this.updateProviderInfo(r.rpcUrl, e)
    }
    async disconnect() {
        this._relay && this._relay.resetAndReload(), this._storage.clear()
    }
    async request(e) {
        try {
            return this._request(e).catch((e => {
                throw e
            }))
        } catch (t) {
            return Promise.reject(t)
        }
    }
    async _request(e) {
        if (!e || "object" != typeof e || Array.isArray(e)) throw $s.standardErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: e
        });
        const {
            method: t,
            params: n
        } = e;
        if ("string" != typeof t || 0 === t.length) throw $s.standardErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: e
        });
        if (void 0 !== n && !Array.isArray(n) && ("object" != typeof n || null === n)) throw $s.standardErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: e
        });
        const r = void 0 === n ? [] : n,
            i = this._relayEventManager.makeRequestId();
        return (await this._sendRequestAsync({
            method: t,
            params: r,
            jsonrpc: "2.0",
            id: i
        })).result
    }
    _setAddresses(e, t) {
        var n;
        if (!Array.isArray(e)) throw new Error("addresses is not an array");
        const r = e.map((e => (0, Ys.ensureAddressString)(e)));
        JSON.stringify(r) !== JSON.stringify(this._addresses) && (this._addresses = r, null === (n = this.updateListener) || void 0 === n || n.onAccountsUpdate({
            accounts: r,
            source: "wallet"
        }), this._storage.setItem(zs.LOCAL_STORAGE_ADDRESSES_KEY, r.join(" ")))
    }
    _sendRequestAsync(e) {
        return new Promise(((t, n) => {
            try {
                const n = this._handleSynchronousMethods(e);
                if (void 0 !== n) return t({
                    jsonrpc: "2.0",
                    id: e.id,
                    result: n
                })
            } catch (r) {
                return n(r)
            }
            this._handleAsynchronousMethods(e).then((n => n && t(Object.assign(Object.assign({}, n), {
                id: e.id
            })))).catch((e => n(e)))
        }))
    }
    _handleSynchronousMethods(e) {
        const {
            method: t
        } = e;
        switch (t) {
            case "eth_accounts":
                return this._eth_accounts();
            case "eth_coinbase":
                return this._eth_coinbase();
            case "net_version":
                return this._net_version();
            case "eth_chainId":
                return this._eth_chainId();
            default:
                return
        }
    }
    async _handleAsynchronousMethods(e) {
        const {
            method: t
        } = e, n = e.params || [];
        switch (t) {
            case "eth_requestAccounts":
                return this._eth_requestAccounts();
            case "eth_sign":
                return this._eth_sign(n);
            case "eth_ecRecover":
                return this._eth_ecRecover(n);
            case "personal_sign":
                return this._personal_sign(n);
            case "personal_ecRecover":
                return this._personal_ecRecover(n);
            case "eth_signTransaction":
                return this._eth_signTransaction(n);
            case "eth_sendRawTransaction":
                return this._eth_sendRawTransaction(n);
            case "eth_sendTransaction":
                return this._eth_sendTransaction(n);
            case "eth_signTypedData_v1":
                return this._eth_signTypedData_v1(n);
            case "eth_signTypedData_v2":
            default:
                return this._throwUnsupportedMethodError();
            case "eth_signTypedData_v3":
                return this._eth_signTypedData_v3(n);
            case "eth_signTypedData_v4":
            case "eth_signTypedData":
                return this._eth_signTypedData_v4(n);
            case "wallet_addEthereumChain":
                return this._wallet_addEthereumChain(n);
            case "wallet_switchEthereumChain":
                return this._wallet_switchEthereumChain(n);
            case "wallet_watchAsset":
                return this._wallet_watchAsset(n)
        }
    }
    _isKnownAddress(e) {
        try {
            const t = (0, Ys.ensureAddressString)(e);
            return this._addresses.map((e => (0, Ys.ensureAddressString)(e))).includes(t)
        } catch (t) {}
        return !1
    }
    _ensureKnownAddress(e) {
        if (!this._isKnownAddress(e)) throw new Error("Unknown Ethereum address")
    }
    _prepareTransactionParams(e) {
        const t = e.from ? (0, Ys.ensureAddressString)(e.from) : this.selectedAddress;
        if (!t) throw new Error("Ethereum address is unavailable");
        this._ensureKnownAddress(t);
        return {
            fromAddress: t,
            toAddress: e.to ? (0, Ys.ensureAddressString)(e.to) : null,
            weiValue: null != e.value ? (0, Ys.ensureBigInt)(e.value) : BigInt(0),
            data: e.data ? (0, Ys.ensureBuffer)(e.data) : Buffer.alloc(0),
            nonce: null != e.nonce ? (0, Ys.ensureIntNumber)(e.nonce) : null,
            gasPriceInWei: null != e.gasPrice ? (0, Ys.ensureBigInt)(e.gasPrice) : null,
            maxFeePerGas: null != e.maxFeePerGas ? (0, Ys.ensureBigInt)(e.maxFeePerGas) : null,
            maxPriorityFeePerGas: null != e.maxPriorityFeePerGas ? (0, Ys.ensureBigInt)(e.maxPriorityFeePerGas) : null,
            gasLimit: null != e.gas ? (0, Ys.ensureBigInt)(e.gas) : null,
            chainId: e.chainId ? (0, Ys.ensureIntNumber)(e.chainId) : this.getChainId()
        }
    }
    _isAuthorized() {
        return this._addresses.length > 0
    }
    _requireAuthorization() {
        if (!this._isAuthorized()) throw $s.standardErrors.provider.unauthorized({})
    }
    _throwUnsupportedMethodError() {
        throw $s.standardErrors.provider.unsupportedMethod({})
    }
    async _signEthereumMessage(e, t, n, r) {
        this._ensureKnownAddress(t);
        try {
            const i = this.initializeRelay(),
                s = await i.signEthereumMessage(e, t, n, r);
            if ((0, Ks.isErrorResponse)(s)) throw new Error(s.errorMessage);
            return {
                jsonrpc: "2.0",
                id: 0,
                result: s.result
            }
        } catch (i) {
            if ("string" == typeof i.message && i.message.match(/(denied|rejected)/i)) throw $s.standardErrors.provider.userRejectedRequest("User denied message signature");
            throw i
        }
    }
    async _ethereumAddressFromSignedMessage(e, t, n) {
        const r = this.initializeRelay(),
            i = await r.ethereumAddressFromSignedMessage(e, t, n);
        if ((0, Ks.isErrorResponse)(i)) throw new Error(i.errorMessage);
        return {
            jsonrpc: "2.0",
            id: 0,
            result: i.result
        }
    }
    _eth_accounts() {
        return [...this._addresses]
    }
    _eth_coinbase() {
        return this.selectedAddress || null
    }
    _net_version() {
        return this.getChainId().toString(10)
    }
    _eth_chainId() {
        return (0, Ys.hexStringFromIntNumber)(this.getChainId())
    }
    getChainId() {
        const e = this._storage.getItem(Qs);
        if (!e) return (0, Ys.ensureIntNumber)(1);
        const t = parseInt(e, 10);
        return (0, Ys.ensureIntNumber)(t)
    }
    async _eth_requestAccounts() {
        if (this._isAuthorized()) return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
        });
        let e;
        try {
            const t = this.initializeRelay();
            if (e = await t.requestEthereumAccounts(), (0, Ks.isErrorResponse)(e)) throw new Error(e.errorMessage)
        } catch (t) {
            if ("string" == typeof t.message && t.message.match(/(denied|rejected)/i)) throw $s.standardErrors.provider.userRejectedRequest("User denied account authorization");
            throw t
        }
        if (!e.result) throw new Error("accounts received is empty");
        return this._setAddresses(e.result), {
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
        }
    }
    _eth_sign(e) {
        this._requireAuthorization();
        const t = (0, Ys.ensureAddressString)(e[0]),
            n = (0, Ys.ensureBuffer)(e[1]);
        return this._signEthereumMessage(n, t, !1)
    }
    _eth_ecRecover(e) {
        const t = (0, Ys.ensureBuffer)(e[0]),
            n = (0, Ys.ensureBuffer)(e[1]);
        return this._ethereumAddressFromSignedMessage(t, n, !1)
    }
    _personal_sign(e) {
        this._requireAuthorization();
        const t = (0, Ys.ensureBuffer)(e[0]),
            n = (0, Ys.ensureAddressString)(e[1]);
        return this._signEthereumMessage(t, n, !0)
    }
    _personal_ecRecover(e) {
        const t = (0, Ys.ensureBuffer)(e[0]),
            n = (0, Ys.ensureBuffer)(e[1]);
        return this._ethereumAddressFromSignedMessage(t, n, !0)
    }
    async _eth_signTransaction(e) {
        this._requireAuthorization();
        const t = this._prepareTransactionParams(e[0] || {});
        try {
            const e = this.initializeRelay(),
                n = await e.signEthereumTransaction(t);
            if ((0, Ks.isErrorResponse)(n)) throw new Error(n.errorMessage);
            return {
                jsonrpc: "2.0",
                id: 0,
                result: n.result
            }
        } catch (n) {
            if ("string" == typeof n.message && n.message.match(/(denied|rejected)/i)) throw $s.standardErrors.provider.userRejectedRequest("User denied transaction signature");
            throw n
        }
    }
    async _eth_sendRawTransaction(e) {
        const t = (0, Ys.ensureBuffer)(e[0]),
            n = this.initializeRelay(),
            r = await n.submitEthereumTransaction(t, this.getChainId());
        if ((0, Ks.isErrorResponse)(r)) throw new Error(r.errorMessage);
        return {
            jsonrpc: "2.0",
            id: 0,
            result: r.result
        }
    }
    async _eth_sendTransaction(e) {
        this._requireAuthorization();
        const t = this._prepareTransactionParams(e[0] || {});
        try {
            const e = this.initializeRelay(),
                n = await e.signAndSubmitEthereumTransaction(t);
            if ((0, Ks.isErrorResponse)(n)) throw new Error(n.errorMessage);
            return {
                jsonrpc: "2.0",
                id: 0,
                result: n.result
            }
        } catch (n) {
            if ("string" == typeof n.message && n.message.match(/(denied|rejected)/i)) throw $s.standardErrors.provider.userRejectedRequest("User denied transaction signature");
            throw n
        }
    }
    async _eth_signTypedData_v1(e) {
        this._requireAuthorization();
        const t = (0, Ys.ensureParsedJSONObject)(e[0]),
            n = (0, Ys.ensureAddressString)(e[1]);
        this._ensureKnownAddress(n);
        const r = Fs.default.hashForSignTypedDataLegacy({
                data: t
            }),
            i = JSON.stringify(t, null, 2);
        return this._signEthereumMessage(r, n, !1, i)
    }
    async _eth_signTypedData_v3(e) {
        this._requireAuthorization();
        const t = (0, Ys.ensureAddressString)(e[0]),
            n = (0, Ys.ensureParsedJSONObject)(e[1]);
        this._ensureKnownAddress(t);
        const r = Fs.default.hashForSignTypedData_v3({
                data: n
            }),
            i = JSON.stringify(n, null, 2);
        return this._signEthereumMessage(r, t, !1, i)
    }
    async _eth_signTypedData_v4(e) {
        this._requireAuthorization();
        const t = (0, Ys.ensureAddressString)(e[0]),
            n = (0, Ys.ensureParsedJSONObject)(e[1]);
        this._ensureKnownAddress(t);
        const r = Fs.default.hashForSignTypedData_v4({
                data: n
            }),
            i = JSON.stringify(n, null, 2);
        return this._signEthereumMessage(r, t, !1, i)
    }
    async _wallet_addEthereumChain(e) {
        var t, n, r, i;
        const s = e[0];
        if (0 === (null === (t = s.rpcUrls) || void 0 === t ? void 0 : t.length)) return {
            jsonrpc: "2.0",
            id: 0,
            error: {
                code: 2,
                message: "please pass in at least 1 rpcUrl"
            }
        };
        if (!s.chainName || "" === s.chainName.trim()) throw $s.standardErrors.rpc.invalidParams("chainName is a required field");
        if (!s.nativeCurrency) throw $s.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
        const a = parseInt(s.chainId, 16);
        return await this.addEthereumChain(a, null !== (n = s.rpcUrls) && void 0 !== n ? n : [], null !== (r = s.blockExplorerUrls) && void 0 !== r ? r : [], s.chainName, null !== (i = s.iconUrls) && void 0 !== i ? i : [], s.nativeCurrency) ? {
            jsonrpc: "2.0",
            id: 0,
            result: null
        } : {
            jsonrpc: "2.0",
            id: 0,
            error: {
                code: 2,
                message: "unable to add ethereum chain"
            }
        }
    }
    async _wallet_switchEthereumChain(e) {
        const t = e[0];
        return await this.switchEthereumChain(parseInt(t.chainId, 16)), {
            jsonrpc: "2.0",
            id: 0,
            result: null
        }
    }
    async _wallet_watchAsset(e) {
        const t = Array.isArray(e) ? e[0] : e;
        if (!t.type) throw $s.standardErrors.rpc.invalidParams("Type is required");
        if ("ERC20" !== (null == t ? void 0 : t.type)) throw $s.standardErrors.rpc.invalidParams(`Asset of type '${t.type}' is not supported`);
        if (!(null == t ? void 0 : t.options)) throw $s.standardErrors.rpc.invalidParams("Options are required");
        if (!(null == t ? void 0 : t.options.address)) throw $s.standardErrors.rpc.invalidParams("Address is required");
        const n = this.getChainId(),
            {
                address: r,
                symbol: i,
                image: s,
                decimals: a
            } = t.options;
        return {
            jsonrpc: "2.0",
            id: 0,
            result: await this.watchAsset(t.type, r, i, a, s, n)
        }
    }
    initializeRelay() {
        if (!this._relay) {
            const e = new Zs.WalletLinkRelay({
                linkAPIUrl: Gs.WALLETLINK_URL,
                storage: this._storage
            });
            e.setAppInfo(this._appName, this._appLogoUrl), e.attachUI(), e.setAccountsCallback(((e, t) => this._setAddresses(e, t))), e.setChainCallback(((e, t) => {
                this.updateProviderInfo(t, parseInt(e, 10))
            })), this._relay = e
        }
        return this._relay
    }
};
var ea = {};
Object.defineProperty(ea, "__esModule", {
    value: !0
}), ea.checkErrorForInvalidRequestArgs = ea.getCoinbaseInjectedProvider = ea.getCoinbaseInjectedSigner = ea.fetchRPCRequest = void 0;
const ta = C,
    na = h;

function ra() {
    return globalThis.coinbaseWalletSigner
}
ea.fetchRPCRequest = async function(e, t) {
    if (!t.rpcUrl) throw na.standardErrors.rpc.internal("No RPC URL set for chain");
    const n = Object.assign(Object.assign({}, e), {
            jsonrpc: "2.0",
            id: crypto.randomUUID()
        }),
        r = await window.fetch(t.rpcUrl, {
            method: "POST",
            body: JSON.stringify(n),
            mode: "cors",
            headers: {
                "Content-Type": "application/json",
                "X-Cbw-Sdk-Version": ta.LIB_VERSION
            }
        });
    return (await r.json()).result
}, ea.getCoinbaseInjectedSigner = ra, ea.getCoinbaseInjectedProvider = function({
    metadata: e,
    preference: t
}) {
    var n, r, i;
    const s = globalThis;
    if ("smartWalletOnly" !== t.options) {
        if (ra()) return;
        const t = s.coinbaseWalletExtension;
        if (t) {
            const {
                appName: r,
                appLogoUrl: i,
                appChainIds: s
            } = e;
            return null === (n = t.setAppInfo) || void 0 === n || n.call(t, r, i, s), t
        }
    }
    const a = null !== (r = s.ethereum) && void 0 !== r ? r : null === (i = s.top) || void 0 === i ? void 0 : i.ethereum;
    if (null == a ? void 0 : a.isCoinbaseBrowser) return a
}, ea.checkErrorForInvalidRequestArgs = function(e) {
    if (!e || "object" != typeof e || Array.isArray(e)) return na.standardErrors.rpc.invalidParams({
        message: "Expected a single, non-array, object argument.",
        data: e
    });
    const {
        method: t,
        params: n
    } = e;
    return "string" != typeof t || 0 === t.length ? na.standardErrors.rpc.invalidParams({
        message: "'args.method' must be a non-empty string.",
        data: e
    }) : void 0 === n || Array.isArray(n) || "object" == typeof n && null !== n ? void 0 : na.standardErrors.rpc.invalidParams({
        message: "'args.params' must be an object or array if provided.",
        data: e
    })
}, Object.defineProperty(K, "__esModule", {
    value: !0
}), K.createSigner = K.fetchSignerType = K.storeSignerType = K.loadSignerType = void 0;
const ia = Z,
    sa = ve,
    aa = h,
    oa = ea,
    ca = "SignerType",
    la = new ee.ScopedLocalStorage("CBWSDK", "SignerConfigurator");
K.loadSignerType = function() {
    return la.getItem(ca)
}, K.storeSignerType = function(e) {
    la.setItem(ca, e)
}, K.fetchSignerType = async function(e) {
    const {
        communicator: t,
        metadata: n
    } = e;
    (async function(e, t) {
        await e.onMessage((({
            event: e
        }) => "WalletLinkSessionRequest" === e));
        const n = new sa.WalletLinkSigner({
            metadata: t
        });
        e.postMessage({
            event: "WalletLinkUpdate",
            data: {
                session: n.getSession()
            }
        }), await n.handshake(), e.postMessage({
            event: "WalletLinkUpdate",
            data: {
                connected: !0
            }
        })
    })(t, n).catch((() => {}));
    const r = {
            id: crypto.randomUUID(),
            event: "selectSignerType",
            data: e.preference
        },
        {
            data: i
        } = await t.postRequestAndWaitForResponse(r);
    return i
}, K.createSigner = function(e) {
    const {
        signerType: t,
        metadata: n,
        communicator: r,
        updateListener: i
    } = e;
    switch (t) {
        case "scw":
            return new ia.SCWSigner({
                metadata: n,
                updateListener: i,
                communicator: r
            });
        case "walletlink":
            return new sa.WalletLinkSigner({
                metadata: n,
                updateListener: i
            });
        case "extension":
            {
                const e = (0, oa.getCoinbaseInjectedSigner)();
                if (!e) throw aa.standardErrors.rpc.internal("injected signer not found");
                return e
            }
    }
};
var ua = {},
    da = {};
Object.defineProperty(da, "__esModule", {
    value: !0
}), da.closePopup = da.openPopup = void 0;
const ha = h;
da.openPopup = function(e) {
    const t = (window.innerWidth - 420) / 2 + window.screenX,
        n = (window.innerHeight - 540) / 2 + window.screenY,
        r = window.open(e, "Smart Wallet", `width=420, height=540, left=${t}, top=${n}`);
    if (null == r || r.focus(), !r) throw ha.standardErrors.rpc.internal("Pop up window failed to open");
    return r
}, da.closePopup = function(e) {
    e && !e.closed && e.close()
}, Object.defineProperty(ua, "__esModule", {
    value: !0
}), ua.Communicator = void 0;
const fa = C,
    pa = da,
    _a = Is,
    ga = h;
ua.Communicator = class {
    constructor(e = _a.CB_KEYS_URL) {
        this.popup = null, this.listeners = new Map, this.postMessage = async e => {
            (await this.waitForPopupLoaded()).postMessage(e, this.url.origin)
        }, this.postRequestAndWaitForResponse = async e => {
            const t = this.onMessage((({
                requestId: t
            }) => t === e.id));
            return this.postMessage(e), await t
        }, this.onMessage = async e => new Promise(((t, n) => {
            const r = n => {
                if (n.origin !== this.url.origin) return;
                const i = n.data;
                e(i) && (t(i), window.removeEventListener("message", r), this.listeners.delete(r))
            };
            window.addEventListener("message", r), this.listeners.set(r, {
                reject: n
            })
        })), this.disconnect = () => {
            (0, pa.closePopup)(this.popup), this.popup = null, this.listeners.forEach((({
                reject: e
            }, t) => {
                e(ga.standardErrors.provider.userRejectedRequest("Request rejected")), window.removeEventListener("message", t)
            })), this.listeners.clear()
        }, this.waitForPopupLoaded = async () => this.popup && !this.popup.closed ? this.popup : (this.popup = (0, pa.openPopup)(this.url), this.onMessage((({
            event: e
        }) => "PopupUnload" === e)).then(this.disconnect).catch((() => {})), this.onMessage((({
            event: e
        }) => "PopupLoaded" === e)).then((e => {
            this.postMessage({
                requestId: e.id,
                data: {
                    version: fa.LIB_VERSION
                }
            })
        })).then((() => {
            if (!this.popup) throw ga.standardErrors.rpc.internal();
            return this.popup
        }))), this.url = new URL(e)
    }
};
var ma = {};
Object.defineProperty(ma, "__esModule", {
    value: !0
}), ma.determineMethodCategory = void 0;
const ba = {
    handshake: ["eth_requestAccounts"],
    sign: ["eth_ecRecover", "personal_sign", "personal_ecRecover", "eth_signTransaction", "eth_sendTransaction", "eth_signTypedData_v1", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_signTypedData", "wallet_addEthereumChain", "wallet_switchEthereumChain", "wallet_watchAsset", "wallet_getCapabilities", "wallet_sendCalls", "wallet_showCallsStatus"],
    state: ["eth_chainId", "eth_accounts", "eth_coinbase", "net_version"],
    deprecated: ["eth_sign", "eth_signTypedData_v2"],
    unsupported: ["eth_subscribe", "eth_unsubscribe"],
    fetch: []
};
ma.determineMethodCategory = function(e) {
    for (const t in ba) {
        const n = t;
        if (ba[n].includes(e)) return n
    }
};
var ya = t && t.__rest || function(e, t) {
        var n = {};
        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
            var i = 0;
            for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
        }
        return n
    },
    va = t && t.__importDefault || function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    };
Object.defineProperty(l, "__esModule", {
    value: !0
}), l.CoinbaseWalletProvider = void 0;
const wa = va(d),
    Ea = h,
    Sa = S,
    ka = L,
    Ca = P,
    Ia = K,
    Ma = ea,
    Ra = ua,
    xa = ma,
    La = ee;
class Aa extends wa.default {
    constructor(e) {
        var t, n, {
                metadata: r
            } = e,
            i = e.preference,
            {
                keysUrl: s
            } = i,
            a = ya(i, ["keysUrl"]);
        super(), this.accounts = [], this.handlers = {
            handshake: async e => {
                try {
                    if (this.connected) return this.emit("connect", {
                        chainId: (0, Ca.hexStringFromIntNumber)((0, ka.IntNumber)(this.chain.id))
                    }), this.accounts;
                    const e = await this.requestSignerSelection(),
                        t = this.initSigner(e),
                        n = await t.handshake();
                    return this.signer = t, (0, Ia.storeSignerType)(e), this.emit("connect", {
                        chainId: (0, Ca.hexStringFromIntNumber)((0, ka.IntNumber)(this.chain.id))
                    }), n
                } catch (t) {
                    throw this.handleUnauthorizedError(t), t
                }
            },
            sign: async e => {
                if (!this.connected || !this.signer) throw Ea.standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
                try {
                    return await this.signer.request(e)
                } catch (t) {
                    throw this.handleUnauthorizedError(t), t
                }
            },
            fetch: e => (0, Ma.fetchRPCRequest)(e, this.chain),
            state: e => {
                const t = () => {
                    if (this.connected) return this.accounts;
                    throw Ea.standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods")
                };
                switch (e.method) {
                    case "eth_chainId":
                        return (0, Ca.hexStringFromIntNumber)((0, ka.IntNumber)(this.chain.id));
                    case "net_version":
                        return this.chain.id;
                    case "eth_accounts":
                        return t();
                    case "eth_coinbase":
                        return t()[0];
                    default:
                        return this.handlers.unsupported(e)
                }
            },
            deprecated: ({
                method: e
            }) => {
                throw Ea.standardErrors.rpc.methodNotSupported(`Method ${e} is deprecated.`)
            },
            unsupported: ({
                method: e
            }) => {
                throw Ea.standardErrors.rpc.methodNotSupported(`Method ${e} is not supported.`)
            }
        }, this.isCoinbaseWallet = !0, this.updateListener = {
            onAccountsUpdate: ({
                accounts: e,
                source: t
            }) => {
                (0, Ca.areAddressArraysEqual)(this.accounts, e) || (this.accounts = e, "storage" !== t && this.emit("accountsChanged", this.accounts))
            },
            onChainUpdate: ({
                chain: e,
                source: t
            }) => {
                e.id === this.chain.id && e.rpcUrl === this.chain.rpcUrl || (this.chain = e, "storage" !== t && this.emit("chainChanged", (0, Ca.hexStringFromIntNumber)((0, ka.IntNumber)(e.id))))
            }
        }, this.metadata = r, this.preference = a, this.communicator = new Ra.Communicator(s), this.chain = {
            id: null !== (n = null === (t = r.appChainIds) || void 0 === t ? void 0 : t[0]) && void 0 !== n ? n : 1
        };
        const o = (0, Ia.loadSignerType)();
        this.signer = o ? this.initSigner(o) : null
    }
    get connected() {
        return this.accounts.length > 0
    }
    async request(e) {
        var t;
        try {
            const n = (0, Ma.checkErrorForInvalidRequestArgs)(e);
            if (n) throw n;
            const r = null !== (t = (0, xa.determineMethodCategory)(e.method)) && void 0 !== t ? t : "fetch";
            return this.handlers[r](e)
        } catch (n) {
            return Promise.reject((0, Sa.serializeError)(n, e.method))
        }
    }
    handleUnauthorizedError(e) {
        e.code === Ea.standardErrorCodes.provider.unauthorized && this.disconnect()
    }
    async enable() {
        return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'), await this.request({
            method: "eth_requestAccounts"
        })
    }
    async disconnect() {
        this.accounts = [], this.chain = {
            id: 1
        }, La.ScopedLocalStorage.clearAll(), this.emit("disconnect", Ea.standardErrors.provider.disconnected("User initiated disconnection"))
    }
    requestSignerSelection() {
        return (0, Ia.fetchSignerType)({
            communicator: this.communicator,
            preference: this.preference,
            metadata: this.metadata
        })
    }
    initSigner(e) {
        return (0, Ia.createSigner)({
            signerType: e,
            metadata: this.metadata,
            communicator: this.communicator,
            updateListener: this.updateListener
        })
    }
}
l.CoinbaseWalletProvider = Aa, Object.defineProperty(o, "__esModule", {
    value: !0
}), o.CoinbaseWalletSDK = void 0;
const Pa = c,
    Ta = l,
    ja = ee,
    Na = C,
    Oa = P,
    Da = ea;
o.CoinbaseWalletSDK = class {
        constructor(e) {
            this.metadata = {
                appName: e.appName || "Dapp",
                appLogoUrl: e.appLogoUrl || (0, Oa.getFavicon)(),
                appChainIds: e.appChainIds || []
            }, this.storeLatestVersion()
        }
        makeWeb3Provider(e = {
            options: "all"
        }) {
            var t;
            const n = {
                metadata: this.metadata,
                preference: e
            };
            return null !== (t = (0, Da.getCoinbaseInjectedProvider)(n)) && void 0 !== t ? t : new Ta.CoinbaseWalletProvider(n)
        }
        getCoinbaseWalletLogo(e, t = 240) {
            return (0, Pa.walletLogo)(e, t)
        }
        storeLatestVersion() {
            new ja.ScopedLocalStorage("CBWSDK").setItem("VERSION", Na.LIB_VERSION)
        }
    },
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.CoinbaseWalletSDK = void 0;
        const t = o;
        e.default = t.CoinbaseWalletSDK;
        var n = o;
        Object.defineProperty(e, "CoinbaseWalletSDK", {
            enumerable: !0,
            get: function() {
                return n.CoinbaseWalletSDK
            }
        })
    }(a);
const Ba = r(a),
    Ua = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ba
    }, Symbol.toStringTag, {
        value: "Module"
    }));
export {
    Ua as i
};